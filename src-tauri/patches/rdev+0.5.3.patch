diff --git a/.cargo-ok b/.cargo-ok
new file mode 100644
index 0000000..5f8b795
--- /dev/null
+++ b/.cargo-ok
@@ -0,0 +1 @@
+{"v":1}
\ No newline at end of file
diff --git a/.cargo_vcs_info.json b/.cargo_vcs_info.json
new file mode 100644
index 0000000..8ce4450
--- /dev/null
+++ b/.cargo_vcs_info.json
@@ -0,0 +1,6 @@
+{
+  "git": {
+    "sha1": "0e2a1c8bb0c2b58f31ed3105c3a800695f7497f9"
+  },
+  "path_in_vcs": ""
+}
\ No newline at end of file
diff --git a/.github/workflows/rust.yml b/.github/workflows/rust.yml
new file mode 100644
index 0000000..ec1b994
--- /dev/null
+++ b/.github/workflows/rust.yml
@@ -0,0 +1,48 @@
+name: build
+
+on: [push, pull_request]
+
+jobs:
+  build:
+
+    runs-on: ${{matrix.os}}
+    env:
+      DISPLAY: ':99'
+    strategy:
+      fail-fast: false
+      matrix: 
+        os: [macos-latest, ubuntu-latest, windows-latest]
+        include:
+        - os: ubuntu-latest
+          headless: Xvfb :99 -screen 0 1024x768x24 > /dev/null 2>&1 &
+        - os: ubuntu-latest
+          dependencies: sudo apt-get install libxtst-dev libevdev-dev --assume-yes
+        - os: macos-latest
+          # TODO: We can't test this on github, we can't set accessibility yet.
+          test: cargo test --verbose --all-features -- --skip test_listen_and_simulate --skip test_grab
+        - os: ubuntu-latest
+          # TODO unstable_grab feature is not supported on Linux.
+          test: cargo test --verbose --features=serialize
+        - os: windows-latest
+          test: cargo test --verbose --all-features
+
+    steps:
+    - uses: actions/checkout@v2
+    - name: CargoFmt
+      run: rustup component add rustfmt
+    - name: Dependencies
+      run: ${{matrix.dependencies}}
+    - name: Setup headless environment
+      run: ${{matrix.headless}}
+    - name: Check formatting
+      run: |
+        rustup component add rustfmt
+        cargo fmt -- --check
+    - name: Build
+      run: cargo build --verbose
+    - name: Run tests
+      run: ${{matrix.test}}
+    - name: Linter
+      run: |
+        rustup component add clippy
+        cargo clippy --all-features --verbose -- -Dwarnings
diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000..96ef6c0
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,2 @@
+/target
+Cargo.lock
diff --git a/Cargo.toml b/Cargo.toml
new file mode 100644
index 0000000..4eb06b5
--- /dev/null
+++ b/Cargo.toml
@@ -0,0 +1,126 @@
+# THIS FILE IS AUTOMATICALLY GENERATED BY CARGO
+#
+# When uploading crates to the registry Cargo will automatically
+# "normalize" Cargo.toml files for maximal compatibility
+# with all versions of Cargo and also rewrite `path` dependencies
+# to registry (e.g., crates.io) dependencies.
+#
+# If you are reading this file be aware that the original Cargo.toml
+# will likely look very different (and much more reasonable).
+# See Cargo.toml.orig for the original contents.
+
+[package]
+edition = "2018"
+name = "rdev"
+version = "0.5.3"
+authors = ["Nicolas Patry <patry.nicolas@protonmail.com>"]
+description = "Listen and send keyboard and mouse events on Windows, Linux and MacOS."
+homepage = "https://github.com/Narsil/rdev"
+documentation = "https://docs.rs/rdev/"
+readme = "README.md"
+keywords = [
+    "input",
+    "mouse",
+    "testing",
+    "keyboard",
+    "automation",
+]
+categories = [
+    "development-tools::testing",
+    "api-bindings",
+    "hardware-support",
+]
+license = "MIT"
+repository = "https://github.com/Narsil/rdev"
+
+[[example]]
+name = "serialize"
+required-features = ["serialize"]
+
+[[example]]
+name = "grab"
+required-features = ["unstable_grab"]
+
+[[example]]
+name = "tokio_channel"
+required-features = ["unstable_grab"]
+
+[[test]]
+name = "grab"
+path = "tests/grab.rs"
+required-features = ["unstable_grab"]
+
+[dependencies.lazy_static]
+version = "1.4"
+
+[dependencies.serde]
+version = "1.0"
+features = ["derive"]
+optional = true
+
+[dev-dependencies.serde_json]
+version = "1.0"
+
+[dev-dependencies.serial_test]
+version = "0.4"
+
+[dev-dependencies.tokio]
+version = "1.5"
+features = [
+    "sync",
+    "macros",
+    "rt-multi-thread",
+]
+
+[features]
+serialize = ["serde"]
+unstable_grab = [
+    "evdev-rs",
+    "epoll",
+    "inotify",
+]
+
+[target."cfg(target_os = \"linux\")".dependencies.epoll]
+version = "4.1.0"
+optional = true
+
+[target."cfg(target_os = \"linux\")".dependencies.evdev-rs]
+version = "0.4.0"
+optional = true
+
+[target."cfg(target_os = \"linux\")".dependencies.inotify]
+version = "0.8.2"
+optional = true
+default-features = false
+
+[target."cfg(target_os = \"linux\")".dependencies.libc]
+version = "0.2"
+
+[target."cfg(target_os = \"linux\")".dependencies.x11]
+version = "2.18"
+features = [
+    "xlib",
+    "xrecord",
+    "xinput",
+]
+
+[target."cfg(target_os = \"macos\")".dependencies.cocoa]
+version = "0.22"
+
+[target."cfg(target_os = \"macos\")".dependencies.core-foundation]
+version = "0.7"
+
+[target."cfg(target_os = \"macos\")".dependencies.core-foundation-sys]
+version = "0.7"
+
+[target."cfg(target_os = \"macos\")".dependencies.core-graphics]
+version = "0.19.0"
+features = ["highsierra"]
+
+[target."cfg(target_os = \"windows\")".dependencies.winapi]
+version = "0.3"
+features = [
+    "winuser",
+    "errhandlingapi",
+    "processthreadsapi",
+]
diff --git a/Cargo.toml.orig b/Cargo.toml.orig
new file mode 100644
index 0000000..6f37864
--- /dev/null
+++ b/Cargo.toml.orig
@@ -0,0 +1,64 @@
+[package]
+name = "rdev"
+version = "0.5.3"
+authors = ["Nicolas Patry <patry.nicolas@protonmail.com>"]
+edition = "2018"
+
+description = "Listen and send keyboard and mouse events on Windows, Linux and MacOS."
+documentation = "https://docs.rs/rdev/"
+homepage = "https://github.com/Narsil/rdev"
+repository = "https://github.com/Narsil/rdev"
+readme = "README.md"
+keywords = ["input", "mouse", "testing", "keyboard", "automation"]
+categories = ["development-tools::testing", "api-bindings", "hardware-support"]
+license = "MIT"
+
+[dependencies]
+serde = {version = "1.0", features = ["derive"], optional=true}
+lazy_static = "1.4"
+
+[features]
+serialize = ["serde"]
+unstable_grab = ["evdev-rs", "epoll", "inotify"]
+
+[target.'cfg(target_os = "macos")'.dependencies]
+cocoa = "0.22"
+core-graphics = {version = "0.19.0", features = ["highsierra"]}
+core-foundation = {version = "0.7"}
+core-foundation-sys = {version = "0.7"}
+
+
+[target.'cfg(target_os = "linux")'.dependencies]
+libc = "0.2"
+x11 = {version = "2.18", features = ["xlib", "xrecord", "xinput"]}
+evdev-rs = {version = "0.4.0", optional=true}
+epoll = {version = "4.1.0", optional=true}
+inotify = {version = "0.8.2", default-features=false, optional=true}
+
+[target.'cfg(target_os = "windows")'.dependencies]
+winapi = { version = "0.3", features = ["winuser", "errhandlingapi", "processthreadsapi"] }
+
+[dev-dependencies]
+serde_json = "1.0"
+# Some tests interact with the real OS. We can't hit the OS in parallel
+# because that leads to unexpected behavior and flaky tests, so we need
+# to run thoses tests in sequence instead.
+serial_test = "0.4"
+tokio = {version = "1.5", features=["sync", "macros", "rt-multi-thread"]}
+
+[[example]]
+name = "serialize"
+required-features = ["serialize"]
+
+[[example]]
+name = "grab"
+required-features = ["unstable_grab"]
+
+[[example]]
+name = "tokio_channel"
+required-features = ["unstable_grab"]
+
+[[test]]
+name = "grab"
+path = "tests/grab.rs"
+required-features = ["unstable_grab"]
diff --git a/LICENSE b/LICENSE
new file mode 100644
index 0000000..5be1138
--- /dev/null
+++ b/LICENSE
@@ -0,0 +1,21 @@
+MIT License
+
+Copyright (c) 2020 Nicolas Patry
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in all
+copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+SOFTWARE.
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..e247236
--- /dev/null
+++ b/README.md
@@ -0,0 +1,220 @@
+![](https://github.com/Narsil/rdev/workflows/build/badge.svg)
+[![Crate](https://img.shields.io/crates/v/rdev.svg)](https://crates.io/crates/rdev)
+[![API](https://docs.rs/rdev/badge.svg)](https://docs.rs/rdev)
+
+# rdev
+
+Simple library to listen and send events **globally** to keyboard and mouse on macOS, Windows and Linux
+(x11).
+
+You can also check out [Enigo](https://github.com/Enigo-rs/Enigo) which is another
+crate which helped me write this one.
+
+This crate is so far a pet project for me to understand the Rust ecosystem.
+
+## Listening to global events
+
+```rust
+use rdev::{listen, Event};
+
+// This will block.
+if let Err(error) = listen(callback) {
+    println!("Error: {:?}", error)
+}
+
+fn callback(event: Event) {
+    println!("My callback {:?}", event);
+    match event.name {
+        Some(string) => println!("User wrote {:?}", string),
+        None => (),
+    }
+}
+```
+
+### OS Caveats:
+When using the `listen` function, the following caveats apply:
+
+### macOS
+The process running the blocking `listen` function (loop) needs to be the parent process (no fork before).
+The process needs to be granted access to the Accessibility API (i.e. if you're running your process
+inside Terminal.app, then Terminal.app needs to be added in
+System Preferences > Security & Privacy > Privacy > Accessibility)
+If the process is not granted access to the Accessibility API, macOS will silently ignore rdev's
+`listen` callback and will not trigger it with events. No error will be generated.
+
+### Linux
+The `listen` function uses X11 APIs, and so will not work in Wayland or in the Linux kernel virtual console
+
+## Sending some events
+
+```rust
+use rdev::{simulate, Button, EventType, Key, SimulateError};
+use std::{thread, time};
+
+fn send(event_type: &EventType) {
+    let delay = time::Duration::from_millis(20);
+    match simulate(event_type) {
+        Ok(()) => (),
+        Err(SimulateError) => {
+            println!("We could not send {:?}", event_type);
+        }
+    }
+    // Let ths OS catchup (at least MacOS)
+    thread::sleep(delay);
+}
+
+send(&EventType::KeyPress(Key::KeyS));
+send(&EventType::KeyRelease(Key::KeyS));
+
+send(&EventType::MouseMove { x: 0.0, y: 0.0 });
+send(&EventType::MouseMove { x: 400.0, y: 400.0 });
+send(&EventType::ButtonPress(Button::Left));
+send(&EventType::ButtonRelease(Button::Right));
+send(&EventType::Wheel {
+    delta_x: 0,
+    delta_y: 1,
+});
+```
+## Main structs
+### Event
+
+In order to detect what a user types, we need to plug to the OS level management
+of keyboard state (modifiers like shift, CTRL, but also dead keys if they exist).
+
+`EventType` corresponds to a *physical* event, corresponding to QWERTY layout
+`Event` corresponds to an actual event that was received and `Event.name` reflects
+what key was interpreted by the OS at that time, it will respect the layout.
+
+```rust
+/// When events arrive from the system we can add some information
+/// time is when the event was received.
+#[derive(Debug)]
+pub struct Event {
+    pub time: SystemTime,
+    pub name: Option<String>,
+    pub event_type: EventType,
+}
+```
+
+Be careful, Event::name, might be None, but also String::from(""), and might contain
+not displayable Unicode characters. We send exactly what the OS sends us, so do some sanity checking
+before using it.
+Caveat: Dead keys don't function yet on Linux
+
+### EventType
+
+In order to manage different OS, the current EventType choices is a mix and match to account for all possible events.
+There is a safe mechanism to detect events no matter what, which are the
+Unknown() variant of the enum which will contain some OS specific value.
+Also, not that not all keys are mapped to an OS code, so simulate might fail if you
+try to send an unmapped key. Sending Unknown() variants will always work (the OS might
+still reject it).
+
+```rust
+/// In order to manage different OS, the current EventType choices is a mix&match
+/// to account for all possible events.
+#[derive(Debug)]
+pub enum EventType {
+    /// The keys correspond to a standard qwerty layout, they don't correspond
+    /// To the actual letter a user would use, that requires some layout logic to be added.
+    KeyPress(Key),
+    KeyRelease(Key),
+    /// Some mouse will have more than 3 buttons, these are not defined, and different OS will
+    /// give different Unknown code.
+    ButtonPress(Button),
+    ButtonRelease(Button),
+    /// Values in pixels
+    MouseMove {
+        x: f64,
+        y: f64,
+    },
+    /// Note: On Linux, there is no actual delta the actual values are ignored for delta_x
+    /// and we only look at the sign of delta_y to simulate wheelup or wheeldown.
+    Wheel {
+        delta_x: i64,
+        delta_y: i64,
+    },
+}
+```
+
+
+## Getting the main screen size
+
+```rust
+use rdev::{display_size};
+
+let (w, h) = display_size().unwrap();
+assert!(w > 0);
+assert!(h > 0);
+```
+
+## Keyboard state
+
+We can define a dummy Keyboard, that we will use to detect
+what kind of EventType trigger some String. We get the currently used
+layout for now !
+Caveat : This is layout dependent. If your app needs to support
+layout switching, don't use this!
+Caveat: On Linux, the dead keys mechanism is not implemented.
+Caveat: Only shift and dead keys are implemented, Alt+Unicode code on Windows won't work.
+
+```rust
+use rdev::{Keyboard, EventType, Key, KeyboardState};
+
+let mut keyboard = Keyboard::new().unwrap();
+let string = keyboard.add(&EventType::KeyPress(Key::KeyS));
+// string == Some("s")
+```
+
+## Grabbing global events. (Requires `unstable_grab` feature)
+
+Installing this library with the `unstable_grab` feature adds the `grab` function
+which hooks into the global input device event stream.
+By supplying this function with a callback, you can intercept
+all keyboard and mouse events before they are delivered to applications / window managers.
+In the callback, returning None ignores the event and returning the event lets it pass.
+There is no modification of the event possible here (yet).
+
+Note: the use of the word `unstable` here refers specifically to the fact that the `grab` API is unstable and subject to change
+
+```rust
+#[cfg(feature = "unstable_grab")]
+use rdev::{grab, Event, EventType, Key};
+
+#[cfg(feature = "unstable_grab")]
+let callback = |event: Event| -> Option<Event> {
+    if let EventType::KeyPress(Key::CapsLock) = event.event_type {
+        println!("Consuming and cancelling CapsLock");
+        None  // CapsLock is now effectively disabled
+    }
+    else { Some(event) }
+};
+// This will block.
+#[cfg(feature = "unstable_grab")]
+if let Err(error) = grab(callback) {
+    println!("Error: {:?}", error)
+}
+```
+
+### OS Caveats:
+When using the `listen` and/or `grab` functions, the following caveats apply:
+
+#### macOS
+The process running the blocking `grab` function (loop) needs to be the parent process (no fork before).
+The process needs to be granted access to the Accessibility API (i.e. if you're running your process
+inside Terminal.app, then Terminal.app needs to be added in
+System Preferences > Security & Privacy > Privacy > Accessibility)
+If the process is not granted access to the Accessibility API, the `grab` call will fail with an
+EventTapError (at least in macOS 10.15, possibly other versions as well)
+
+#### Linux
+The `grab` function use the `evdev` library to intercept events, so they will work with both X11 and Wayland
+In order for this to work, the process running the `listen` or `grab` loop needs to either run as root (not recommended),
+or run as a user who's a member of the `input` group (recommended)
+Note: on some distros, the group name for evdev access is called `plugdev`, and on some systems, both groups can exist.
+When in doubt, add your user to both groups if they exist.
+
+## Serialization
+
+Event data returned by the `listen` and `grab` functions can be serialized and deserialized with
+Serde if you install this library with the `serialize` feature.
diff --git a/README.tpl b/README.tpl
new file mode 100644
index 0000000..9f9061e
--- /dev/null
+++ b/README.tpl
@@ -0,0 +1,8 @@
+![](https://github.com/Narsil/rdev/workflows/build/badge.svg)
+[![Crate](https://img.shields.io/crates/v/rdev.svg)](https://crates.io/crates/rdev)
+[![API](https://docs.rs/rdev/badge.svg)](https://docs.rs/rdev)
+
+# {{crate}}
+
+{{readme}}
+
diff --git a/examples/channel.rs b/examples/channel.rs
new file mode 100644
index 0000000..5f7158a
--- /dev/null
+++ b/examples/channel.rs
@@ -0,0 +1,22 @@
+use rdev::listen;
+use std::sync::mpsc::channel;
+use std::thread;
+
+fn main() {
+    // spawn new thread because listen blocks
+    let (schan, rchan) = channel();
+    let _listener = thread::spawn(move || {
+        listen(move |event| {
+            schan
+                .send(event)
+                .unwrap_or_else(|e| println!("Could not send event {:?}", e));
+        })
+        .expect("Could not listen");
+    });
+
+    let mut events = Vec::new();
+    for event in rchan.iter() {
+        println!("Received {:?}", event);
+        events.push(event);
+    }
+}
diff --git a/examples/display.rs b/examples/display.rs
new file mode 100644
index 0000000..b51848a
--- /dev/null
+++ b/examples/display.rs
@@ -0,0 +1,6 @@
+use rdev::display_size;
+fn main() {
+    let (w, h) = display_size().unwrap();
+
+    println!("Your screen is {:?}x{:?}", w, h);
+}
diff --git a/examples/grab.rs b/examples/grab.rs
new file mode 100644
index 0000000..6f7f04a
--- /dev/null
+++ b/examples/grab.rs
@@ -0,0 +1,19 @@
+use rdev::{grab, Event, EventType, Key};
+
+fn main() {
+    // This will block.
+    if let Err(error) = grab(callback) {
+        println!("Error: {:?}", error)
+    }
+}
+
+fn callback(event: Event) -> Option<Event> {
+    println!("My callback {:?}", event);
+    match event.event_type {
+        EventType::KeyPress(Key::Tab) => {
+            println!("Cancelling tab !");
+            None
+        }
+        _ => Some(event),
+    }
+}
diff --git a/examples/keyboard_state.rs b/examples/keyboard_state.rs
new file mode 100644
index 0000000..833eee9
--- /dev/null
+++ b/examples/keyboard_state.rs
@@ -0,0 +1,18 @@
+use rdev::{EventType, Key, Keyboard, KeyboardState};
+
+fn main() {
+    let mut keyboard = Keyboard::new().unwrap();
+    let char_s = keyboard.add(&EventType::KeyPress(Key::KeyS)).unwrap();
+    assert_eq!(char_s, "s".to_string());
+    println!("Pressing S gives: {:?}", char_s);
+    let n = keyboard.add(&EventType::KeyRelease(Key::KeyS));
+    assert_eq!(n, None);
+
+    keyboard.add(&EventType::KeyPress(Key::ShiftLeft));
+    let char_s = keyboard.add(&EventType::KeyPress(Key::KeyS)).unwrap();
+    println!("Pressing Shift+S gives: {:?}", char_s);
+    assert_eq!(char_s, "S".to_string());
+    let n = keyboard.add(&EventType::KeyRelease(Key::KeyS));
+    assert_eq!(n, None);
+    keyboard.add(&EventType::KeyRelease(Key::ShiftLeft));
+}
diff --git a/examples/listen.rs b/examples/listen.rs
new file mode 100644
index 0000000..3785294
--- /dev/null
+++ b/examples/listen.rs
@@ -0,0 +1,12 @@
+use rdev::{listen, Event};
+
+fn main() {
+    // This will block.
+    if let Err(error) = listen(callback) {
+        println!("Error: {:?}", error)
+    }
+}
+
+fn callback(event: Event) {
+    println!("My callback {:?}", event);
+}
diff --git a/examples/serialize.rs b/examples/serialize.rs
new file mode 100644
index 0000000..800fceb
--- /dev/null
+++ b/examples/serialize.rs
@@ -0,0 +1,18 @@
+use rdev::{Event, EventType, Key};
+use std::time::SystemTime;
+
+fn main() {
+    let event = Event {
+        event_type: EventType::KeyPress(Key::KeyS),
+        time: SystemTime::now(),
+        name: Some(String::from("S")),
+    };
+
+    let serialized = serde_json::to_string(&event).unwrap();
+
+    let deserialized: Event = serde_json::from_str(&serialized).unwrap();
+
+    println!("Serialized event {:?}", serialized);
+    println!("Deserialized event {:?}", deserialized);
+    assert_eq!(event, deserialized);
+}
diff --git a/examples/simulate.rs b/examples/simulate.rs
new file mode 100644
index 0000000..1f50f04
--- /dev/null
+++ b/examples/simulate.rs
@@ -0,0 +1,28 @@
+use rdev::{simulate, Button, EventType, Key, SimulateError};
+use std::{thread, time};
+
+fn send(event_type: &EventType) {
+    let delay = time::Duration::from_millis(20);
+    match simulate(event_type) {
+        Ok(()) => (),
+        Err(SimulateError) => {
+            println!("We could not send {:?}", event_type);
+        }
+    }
+    // Let ths OS catchup (at least MacOS)
+    thread::sleep(delay);
+}
+
+fn main() {
+    send(&EventType::KeyPress(Key::KeyS));
+    send(&EventType::KeyRelease(Key::KeyS));
+
+    send(&EventType::MouseMove { x: 0.0, y: 0.0 });
+    send(&EventType::MouseMove { x: 400.0, y: 400.0 });
+    send(&EventType::ButtonPress(Button::Left));
+    send(&EventType::ButtonRelease(Button::Right));
+    send(&EventType::Wheel {
+        delta_x: 0,
+        delta_y: 1,
+    });
+}
diff --git a/examples/tokio_channel.rs b/examples/tokio_channel.rs
new file mode 100644
index 0000000..57b29cf
--- /dev/null
+++ b/examples/tokio_channel.rs
@@ -0,0 +1,22 @@
+use rdev::listen;
+use std::thread;
+use tokio::sync::mpsc;
+
+#[tokio::main]
+async fn main() {
+    // spawn new thread because listen blocks
+    let (schan, mut rchan) = mpsc::unbounded_channel();
+    let _listener = thread::spawn(move || {
+        listen(move |event| {
+            schan
+                .send(event)
+                .unwrap_or_else(|e| println!("Could not send event {:?}", e));
+        })
+        .expect("Could not listen");
+    });
+
+    loop {
+        let event = rchan.recv().await;
+        println!("Received {:?}", event);
+    }
+}
diff --git a/rustfmt.toml b/rustfmt.toml
new file mode 100644
index 0000000..c51666e
--- /dev/null
+++ b/rustfmt.toml
@@ -0,0 +1 @@
+edition = "2018"
\ No newline at end of file
diff --git a/src/lib.rs b/src/lib.rs
new file mode 100644
index 0000000..7be78c7
--- /dev/null
+++ b/src/lib.rs
@@ -0,0 +1,447 @@
+//! Simple library to listen and send events to keyboard and mouse on MacOS, Windows and Linux
+//! (x11).
+//!
+//! You can also check out [Enigo](https://github.com/Enigo-rs/Enigo) which is another
+//! crate which helped me write this one.
+//!
+//! This crate is so far a pet project for me to understand the rust ecosystem.
+//!
+//! # Listening to global events
+//!
+//! ```no_run
+//! use rdev::{listen, Event};
+//!
+//! // This will block.
+//! if let Err(error) = listen(callback) {
+//!     println!("Error: {:?}", error)
+//! }
+//!
+//! fn callback(event: Event) {
+//!     println!("My callback {:?}", event);
+//!     match event.name {
+//!         Some(string) => println!("User wrote {:?}", string),
+//!         None => (),
+//!     }
+//! }
+//! ```
+//!
+//! ## OS Caveats:
+//! When using the `listen` function, the following caveats apply:
+//!
+//! ## Mac OS
+//! The process running the blocking `listen` function (loop) needs to be the parent process (no fork before).
+//! The process needs to be granted access to the Accessibility API (ie. if you're running your process
+//! inside Terminal.app, then Terminal.app needs to be added in
+//! System Preferences > Security & Privacy > Privacy > Accessibility)
+//! If the process is not granted access to the Accessibility API, MacOS will silently ignore rdev's
+//! `listen` calleback and will not trigger it with events. No error will be generated.
+//!
+//! ## Linux
+//! The `listen` function uses X11 APIs, and so will not work in Wayland or in the linux kernel virtual console
+//!
+//! # Sending some events
+//!
+//! ```no_run
+//! use rdev::{simulate, Button, EventType, Key, SimulateError};
+//! use std::{thread, time};
+//!
+//! fn send(event_type: &EventType) {
+//!     let delay = time::Duration::from_millis(20);
+//!     match simulate(event_type) {
+//!         Ok(()) => (),
+//!         Err(SimulateError) => {
+//!             println!("We could not send {:?}", event_type);
+//!         }
+//!     }
+//!     // Let ths OS catchup (at least MacOS)
+//!     thread::sleep(delay);
+//! }
+//!
+//! send(&EventType::KeyPress(Key::KeyS));
+//! send(&EventType::KeyRelease(Key::KeyS));
+//!
+//! send(&EventType::MouseMove { x: 0.0, y: 0.0 });
+//! send(&EventType::MouseMove { x: 400.0, y: 400.0 });
+//! send(&EventType::ButtonPress(Button::Left));
+//! send(&EventType::ButtonRelease(Button::Right));
+//! send(&EventType::Wheel {
+//!     delta_x: 0,
+//!     delta_y: 1,
+//! });
+//! ```
+//! # Main structs
+//! ## Event
+//!
+//! In order to detect what a user types, we need to plug to the OS level management
+//! of keyboard state (modifiers like shift, ctrl, but also dead keys if they exist).
+//!
+//! `EventType` corresponds to a *physical* event, corresponding to QWERTY layout
+//! `Event` corresponds to an actual event that was received and `Event.name` reflects
+//! what key was interpreted by the OS at that time, it will respect the layout.
+//!
+//! ```no_run
+//! # use crate::rdev::EventType;
+//! # use std::time::SystemTime;
+//! /// When events arrive from the system we can add some information
+//! /// time is when the event was received.
+//! #[derive(Debug)]
+//! pub struct Event {
+//!     pub time: SystemTime,
+//!     pub name: Option<String>,
+//!     pub event_type: EventType,
+//! }
+//! ```
+//!
+//! Be careful, Event::name, might be None, but also String::from(""), and might contain
+//! not displayable unicode characters. We send exactly what the OS sends us so do some sanity checking
+//! before using it.
+//! Caveat: Dead keys don't function yet on Linux
+//!
+//! ## EventType
+//!
+//! In order to manage different OS, the current EventType choices is a mix&match
+//! to account for all possible events.
+//! There is a safe mechanism to detect events no matter what, which are the
+//! Unknown() variant of the enum which will contain some OS specific value.
+//! Also not that not all keys are mapped to an OS code, so simulate might fail if you
+//! try to send an unmapped key. Sending Unknown() variants will always work (the OS might
+//! still reject it).
+//!
+//! ```no_run
+//! # use crate::rdev::{Key, Button};
+//! /// In order to manage different OS, the current EventType choices is a mix&match
+//! /// to account for all possible events.
+//! #[derive(Debug)]
+//! pub enum EventType {
+//!     /// The keys correspond to a standard qwerty layout, they don't correspond
+//!     /// To the actual letter a user would use, that requires some layout logic to be added.
+//!     KeyPress(Key),
+//!     KeyRelease(Key),
+//!     /// Some mouse will have more than 3 buttons, these are not defined, and different OS will
+//!     /// give different Unknown code.
+//!     ButtonPress(Button),
+//!     ButtonRelease(Button),
+//!     /// Values in pixels
+//!     MouseMove {
+//!         x: f64,
+//!         y: f64,
+//!     },
+//!     /// Note: On Linux, there is no actual delta the actual values are ignored for delta_x
+//!     /// and we only look at the sign of delta_y to simulate wheelup or wheeldown.
+//!     Wheel {
+//!         delta_x: i64,
+//!         delta_y: i64,
+//!     },
+//! }
+//! ```
+//!
+//!
+//! # Getting the main screen size
+//!
+//! ```no_run
+//! use rdev::{display_size};
+//!
+//! let (w, h) = display_size().unwrap();
+//! assert!(w > 0);
+//! assert!(h > 0);
+//! ```
+//!
+//! # Keyboard state
+//!
+//! We can define a dummy Keyboard, that we will use to detect
+//! what kind of EventType trigger some String. We get the currently used
+//! layout for now !
+//! Caveat : This is layout dependent. If your app needs to support
+//! layout switching don't use this !
+//! Caveat: On Linux, the dead keys mechanism is not implemented.
+//! Caveat: Only shift and dead keys are implemented, Alt+unicode code on windows
+//! won't work.
+//!
+//! ```no_run
+//! use rdev::{Keyboard, EventType, Key, KeyboardState};
+//!
+//! let mut keyboard = Keyboard::new().unwrap();
+//! let string = keyboard.add(&EventType::KeyPress(Key::KeyS));
+//! // string == Some("s")
+//! ```
+//!
+//! # Grabbing global events. (Requires `unstable_grab` feature)
+//!
+//! Installing this library with the `unstable_grab` feature adds the `grab` function
+//! which hooks into the global input device event stream.
+//! by suppling this function with a callback, you can intercept
+//! all keyboard and mouse events before they are delivered to applications / window managers.
+//! In the callback, returning None ignores the event and returning the event let's it pass.
+//! There is no modification of the event possible here (yet).
+//!
+//! Note: the use of the word `unstable` here refers specifically to the fact that the `grab` API is unstable and subject to change
+//!
+//! ```no_run
+//! #[cfg(feature = "unstable_grab")]
+//! use rdev::{grab, Event, EventType, Key};
+//!
+//! #[cfg(feature = "unstable_grab")]
+//! let callback = |event: Event| -> Option<Event> {
+//!     if let EventType::KeyPress(Key::CapsLock) = event.event_type {
+//!         println!("Consuming and cancelling CapsLock");
+//!         None  // CapsLock is now effectively disabled
+//!     }
+//!     else { Some(event) }
+//! };
+//! // This will block.
+//! #[cfg(feature = "unstable_grab")]
+//! if let Err(error) = grab(callback) {
+//!     println!("Error: {:?}", error)
+//! }
+//! ```
+//!
+//! ## OS Caveats:
+//! When using the `listen` and/or `grab` functions, the following caveats apply:
+//!
+//! ### Mac OS
+//! The process running the blocking `grab` function (loop) needs to be the parent process (no fork before).
+//! The process needs to be granted access to the Accessibility API (ie. if you're running your process
+//! inside Terminal.app, then Terminal.app needs to be added in
+//! System Preferences > Security & Privacy > Privacy > Accessibility)
+//! If the process is not granted access to the Accessibility API, the `grab` call will fail with an
+//! EventTapError (at least in MacOS 10.15, possibly other versions as well)
+//!
+//! ### Linux
+//! The `grab` function use the `evdev` library to intercept events, so they will work with both X11 and Wayland
+//! In order for this to work, the process runnign the `listen` or `grab` loop needs to either run as root (not recommended),
+//! or run as a user who's a member of the `input` group (recommended)
+//! Note: on some distros, the group name for evdev access is called `plugdev`, and on some systems, both groups can exist.
+//! When in doubt, add your user to both groups if they exist.
+//!
+//! # Serialization
+//!
+//! Event data returned by the `listen` and `grab` functions can be serialized and de-serialized with
+//! Serde if you install this library with the `serialize` feature.
+mod rdev;
+pub use crate::rdev::{
+    Button, DisplayError, Event, EventType, GrabCallback, GrabError, Key, KeyboardState,
+    ListenError, SimulateError,
+};
+
+#[cfg(target_os = "macos")]
+mod macos;
+#[cfg(target_os = "macos")]
+pub use crate::macos::Keyboard;
+#[cfg(target_os = "macos")]
+use crate::macos::{display_size as _display_size, listen as _listen, simulate as _simulate, key_from_code as _key_from_code, code_from_key as _code_from_key};
+#[cfg(target_os = "macos")]
+use core_graphics::event::CGKeyCode;
+
+#[cfg(target_os = "linux")]
+mod linux;
+#[cfg(target_os = "linux")]
+pub use crate::linux::Keyboard;
+#[cfg(target_os = "linux")]
+use crate::linux::{display_size as _display_size, listen as _listen, simulate as _simulate, key_from_code as _key_from_code, code_from_key as _code_from_key};
+#[cfg(target_os = "linux")]
+use std::os::raw::c_uint;
+
+#[cfg(target_os = "windows")]
+mod windows;
+#[cfg(target_os = "windows")]
+pub use crate::windows::Keyboard;
+#[cfg(target_os = "windows")]
+use crate::windows::{display_size as _display_size, listen as _listen, simulate as _simulate, key_from_code as _key_from_code, code_from_key as _code_from_key};
+#[cfg(target_os = "windows")]
+use winapi::shared::minwindef::WORD;
+
+#[cfg(target_os = "windows")]
+pub fn key_from_code(code: WORD) -> Key {
+    _key_from_code(code)
+}
+
+#[cfg(target_os = "linux")]
+pub fn key_from_code(code: c_uint) -> Key {
+    _key_from_code(code)
+}
+
+#[cfg(target_os = "macos")]
+pub fn key_from_code(code: CGKeyCode) -> Key {
+    _key_from_code(code)
+}
+
+
+#[cfg(target_os = "windows")]
+pub fn code_from_key(key: Key) -> Option<WORD> {
+    _code_from_key(key)
+}
+
+#[cfg(target_os = "linux")]
+pub fn code_from_key(key: Key) -> Option<c_uint> {
+    _code_from_key(key)
+}
+
+#[cfg(target_os = "macos")]
+pub fn code_from_key(key: Key) -> Option<CGKeyCode> {
+    _code_from_key(key)
+}
+
+/// Listening to global events. Caveat: On MacOS, you require the listen
+/// loop needs to be the primary app (no fork before) and need to have accessibility
+/// settings enabled.
+///
+/// ```no_run
+/// use rdev::{listen, Event};
+///
+/// fn callback(event: Event) {
+///     println!("My callback {:?}", event);
+///     match event.name{
+///         Some(string) => println!("User wrote {:?}", string),
+///         None => ()
+///     }
+/// }
+/// fn main(){
+///     // This will block.
+///     if let Err(error) = listen(callback) {
+///         println!("Error: {:?}", error)
+///     }
+/// }
+/// ```
+pub fn listen<T>(callback: T) -> Result<(), ListenError>
+where
+    T: FnMut(Event) + 'static,
+{
+    _listen(callback)
+}
+
+/// Sending some events
+///
+/// ```no_run
+/// use rdev::{simulate, Button, EventType, Key, SimulateError};
+/// use std::{thread, time};
+///
+/// fn send(event_type: &EventType) {
+///     let delay = time::Duration::from_millis(20);
+///     match simulate(event_type) {
+///         Ok(()) => (),
+///         Err(SimulateError) => {
+///             println!("We could not send {:?}", event_type);
+///         }
+///     }
+///     // Let ths OS catchup (at least MacOS)
+///     thread::sleep(delay);
+/// }
+///
+/// fn my_shortcut() {
+///     send(&EventType::KeyPress(Key::KeyS));
+///     send(&EventType::KeyRelease(Key::KeyS));
+///
+///     send(&EventType::MouseMove { x: 0.0, y: 0.0 });
+///     send(&EventType::MouseMove { x: 400.0, y: 400.0 });
+///     send(&EventType::ButtonPress(Button::Left));
+///     send(&EventType::ButtonRelease(Button::Right));
+///     send(&EventType::Wheel {
+///         delta_x: 0,
+///         delta_y: 1,
+///     });
+/// }
+/// ```
+pub fn simulate(event_type: &EventType) -> Result<(), SimulateError> {
+    _simulate(event_type)
+}
+
+/// Returns the size in pixels of the main screen.
+/// This is useful to use with x, y from MouseMove Event.
+///
+/// ```no_run
+/// use rdev::{display_size};
+///
+/// let (w, h) = display_size().unwrap();
+/// println!("My screen size : {:?}x{:?}", w, h);
+/// ```
+pub fn display_size() -> Result<(u64, u64), DisplayError> {
+    _display_size()
+}
+
+#[cfg(feature = "unstable_grab")]
+#[cfg(target_os = "linux")]
+pub use crate::linux::grab as _grab;
+#[cfg(feature = "unstable_grab")]
+#[cfg(target_os = "macos")]
+pub use crate::macos::grab as _grab;
+#[cfg(feature = "unstable_grab")]
+#[cfg(target_os = "windows")]
+pub use crate::windows::grab as _grab;
+#[cfg(any(feature = "unstable_grab"))]
+/// Grabbing global events. In the callback, returning None ignores the event
+/// and returning the event let's it pass. There is no modification of the event
+/// possible here.
+/// Caveat: On MacOS, you require the grab
+/// loop needs to be the primary app (no fork before) and need to have accessibility
+/// settings enabled.
+/// On Linux, you need rw access to evdev devices in /etc/input/ (usually group membership in `input` group is enough)
+///
+/// ```no_run
+/// use rdev::{grab, Event, EventType, Key};
+///
+/// fn callback(event: Event) -> Option<Event> {
+///     println!("My callback {:?}", event);
+///     match event.event_type{
+///         EventType::KeyPress(Key::Tab) => None,
+///         _ => Some(event),
+///     }
+/// }
+/// fn main(){
+///     // This will block.
+///     if let Err(error) = grab(callback) {
+///         println!("Error: {:?}", error)
+///     }
+/// }
+/// ```
+#[cfg(any(feature = "unstable_grab"))]
+pub fn grab<T>(callback: T) -> Result<(), GrabError>
+where
+    T: Fn(Event) -> Option<Event> + 'static,
+{
+    _grab(callback)
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_keyboard_state() {
+        // S
+        let mut keyboard = Keyboard::new().unwrap();
+        let char_s = keyboard.add(&EventType::KeyPress(Key::KeyS)).unwrap();
+        assert_eq!(
+            char_s,
+            "s".to_string(),
+            "This test should pass only on Qwerty layout !"
+        );
+        let n = keyboard.add(&EventType::KeyRelease(Key::KeyS));
+        assert_eq!(n, None);
+
+        // Shift + S
+        keyboard.add(&EventType::KeyPress(Key::ShiftLeft));
+        let char_s = keyboard.add(&EventType::KeyPress(Key::KeyS)).unwrap();
+        assert_eq!(char_s, "S".to_string());
+        let n = keyboard.add(&EventType::KeyRelease(Key::KeyS));
+        assert_eq!(n, None);
+        keyboard.add(&EventType::KeyRelease(Key::ShiftLeft));
+
+        // Reset
+        keyboard.add(&EventType::KeyPress(Key::ShiftLeft));
+        keyboard.reset();
+        let char_s = keyboard.add(&EventType::KeyPress(Key::KeyS)).unwrap();
+        assert_eq!(char_s, "s".to_string());
+        let n = keyboard.add(&EventType::KeyRelease(Key::KeyS));
+        assert_eq!(n, None);
+        keyboard.add(&EventType::KeyRelease(Key::ShiftLeft));
+
+        // UsIntl layout required
+        // let n = keyboard.add(&EventType::KeyPress(Key::Quote));
+        // assert_eq!(n, Some("".to_string()));
+        // let m = keyboard.add(&EventType::KeyRelease(Key::Quote));
+        // assert_eq!(m, None);
+        // let e = keyboard.add(&EventType::KeyPress(Key::KeyE)).unwrap();
+        // assert_eq!(e, "Ã©".to_string());
+        // keyboard.add(&EventType::KeyRelease(Key::KeyE));
+    }
+}
diff --git a/src/linux/common.rs b/src/linux/common.rs
new file mode 100644
index 0000000..94ecbb9
--- /dev/null
+++ b/src/linux/common.rs
@@ -0,0 +1,138 @@
+use crate::linux::keyboard::Keyboard;
+use crate::linux::keycodes::key_from_code;
+use crate::rdev::{Button, Event, EventType, KeyboardState};
+use std::convert::TryInto;
+use std::os::raw::{c_int, c_uchar, c_uint};
+use std::ptr::null;
+use std::time::SystemTime;
+use x11::xlib;
+
+pub const TRUE: c_int = 1;
+pub const FALSE: c_int = 0;
+
+// A global for the callbacks.
+pub static mut KEYBOARD: Option<Keyboard> = None;
+
+pub fn convert_event(code: c_uchar, type_: c_int, x: f64, y: f64) -> Option<EventType> {
+    match type_ {
+        xlib::KeyPress => {
+            let key = key_from_code(code.into());
+            Some(EventType::KeyPress(key))
+        }
+        xlib::KeyRelease => {
+            let key = key_from_code(code.into());
+            Some(EventType::KeyRelease(key))
+        }
+        xlib::ButtonPress => match code {
+            1 => Some(EventType::ButtonPress(Button::Left)),
+            2 => Some(EventType::ButtonPress(Button::Middle)),
+            3 => Some(EventType::ButtonPress(Button::Right)),
+            4 => Some(EventType::Wheel {
+                delta_y: 1,
+                delta_x: 0,
+            }),
+            5 => Some(EventType::Wheel {
+                delta_y: -1,
+                delta_x: 0,
+            }),
+            6 => Some(EventType::Wheel {
+                delta_y: 0,
+                delta_x: -1,
+            }),
+            7 => Some(EventType::Wheel {
+                delta_y: 0,
+                delta_x: 1,
+            }),
+            code => Some(EventType::ButtonPress(Button::Unknown(code))),
+        },
+        xlib::ButtonRelease => match code {
+            1 => Some(EventType::ButtonRelease(Button::Left)),
+            2 => Some(EventType::ButtonRelease(Button::Middle)),
+            3 => Some(EventType::ButtonRelease(Button::Right)),
+            4 | 5 => None,
+            _ => Some(EventType::ButtonRelease(Button::Unknown(code))),
+        },
+        xlib::MotionNotify => Some(EventType::MouseMove { x, y }),
+        _ => None,
+    }
+}
+
+pub fn convert(
+    keyboard: &mut Option<Keyboard>,
+    code: c_uint,
+    type_: c_int,
+    x: f64,
+    y: f64,
+) -> Option<Event> {
+    let event_type = convert_event(code as c_uchar, type_, x, y)?;
+    let kb: &mut Keyboard = (*keyboard).as_mut()?;
+    let name = kb.add(&event_type);
+    Some(Event {
+        event_type,
+        time: SystemTime::now(),
+        name,
+    })
+}
+
+pub struct Display {
+    display: *mut xlib::Display,
+}
+
+impl Display {
+    pub fn new() -> Option<Display> {
+        unsafe {
+            let display = xlib::XOpenDisplay(null());
+            if display.is_null() {
+                return None;
+            }
+            Some(Display { display })
+        }
+    }
+
+    pub fn get_size(&self) -> Option<(u64, u64)> {
+        unsafe {
+            let screen_ptr = xlib::XDefaultScreenOfDisplay(self.display);
+            if screen_ptr.is_null() {
+                return None;
+            }
+            let screen = *screen_ptr;
+            Some((
+                screen.width.try_into().ok()?,
+                screen.height.try_into().ok()?,
+            ))
+        }
+    }
+
+    #[cfg(feature = "unstable_grab")]
+    pub fn get_mouse_pos(&self) -> Option<(u64, u64)> {
+        unsafe {
+            let root_window = xlib::XRootWindow(self.display, 0);
+            let mut root_x = 0;
+            let mut root_y = 0;
+            let mut x = 0;
+            let mut y = 0;
+            let mut root = 0;
+            let mut child = 0;
+            let mut mask = 0;
+            let _screen_ptr = xlib::XQueryPointer(
+                self.display,
+                root_window,
+                &mut root,
+                &mut child,
+                &mut root_x,
+                &mut root_y,
+                &mut x,
+                &mut y,
+                &mut mask,
+            );
+            Some((root_x.try_into().ok()?, root_y.try_into().ok()?))
+        }
+    }
+}
+impl Drop for Display {
+    fn drop(&mut self) {
+        unsafe {
+            xlib::XCloseDisplay(self.display);
+        }
+    }
+}
diff --git a/src/linux/display.rs b/src/linux/display.rs
new file mode 100644
index 0000000..d50e91f
--- /dev/null
+++ b/src/linux/display.rs
@@ -0,0 +1,7 @@
+use crate::linux::common::Display;
+use crate::rdev::DisplayError;
+
+pub fn display_size() -> Result<(u64, u64), DisplayError> {
+    let display = Display::new().ok_or(DisplayError::NoDisplay)?;
+    display.get_size().ok_or(DisplayError::NoDisplay)
+}
diff --git a/src/linux/grab.rs b/src/linux/grab.rs
new file mode 100644
index 0000000..7ced7d2
--- /dev/null
+++ b/src/linux/grab.rs
@@ -0,0 +1,529 @@
+use crate::linux::common::Display;
+use crate::linux::keyboard::Keyboard;
+use crate::rdev::{Button, Event, EventType, GrabError, Key, KeyboardState};
+use epoll::ControlOptions::{EPOLL_CTL_ADD, EPOLL_CTL_DEL};
+use evdev_rs::{
+    enums::{EventCode, EV_KEY, EV_REL},
+    Device, InputEvent, UInputDevice,
+};
+use inotify::{Inotify, WatchMask};
+use std::ffi::{OsStr, OsString};
+use std::fs::{read_dir, File};
+use std::io;
+use std::os::unix::{
+    ffi::OsStrExt,
+    fs::FileTypeExt,
+    io::{AsRawFd, IntoRawFd, RawFd},
+};
+use std::path::Path;
+use std::time::SystemTime;
+
+// TODO The x, y coordinates are currently wrong !! Is there mouse acceleration
+// to take into account ??
+
+macro_rules! convert_keys {
+    ($($ev_key:ident, $rdev_key:ident),*) => {
+        //TODO: make const when rust lang issue #49146 is fixed
+        #[allow(unreachable_patterns)]
+        fn evdev_key_to_rdev_key(key: &EV_KEY) -> Option<Key> {
+            match key {
+                $(
+                    EV_KEY::$ev_key => Some(Key::$rdev_key),
+                )*
+                _ => None,
+            }
+        }
+
+        // //TODO: make const when rust lang issue #49146 is fixed
+        // fn rdev_key_to_evdev_key(key: &Key) -> Option<EV_KEY> {
+        //     match key {
+        //         $(
+        //             Key::$rdev_key => Some(EV_KEY::$ev_key),
+        //         )*
+        //         _ => None
+        //     }
+        // }
+    };
+}
+
+macro_rules! convert_buttons {
+    ($($ev_key:ident, $rdev_key:ident),*) => {
+        //TODO: make const when rust lang issue #49146 is fixed
+        fn evdev_key_to_rdev_button(key: &EV_KEY) -> Option<Button> {
+            match key {
+                $(
+                    EV_KEY::$ev_key => Some(Button::$rdev_key),
+                )*
+                _ => None,
+            }
+        }
+
+        // //TODO: make const when rust lang issue #49146 is fixed
+        // fn rdev_button_to_evdev_key(event: &Button) -> Option<EV_KEY> {
+        //     match event {
+        //         $(
+        //             Button::$rdev_key => Some(EV_KEY::$ev_key),
+        //         )*
+        //         _ => None
+        //     }
+        // }
+    };
+}
+
+#[rustfmt::skip]
+convert_buttons!(
+    BTN_LEFT, Left,
+    BTN_RIGHT, Right,
+    BTN_MIDDLE, Middle
+);
+
+//TODO: IntlBackslash, kpDelete
+#[rustfmt::skip]
+convert_keys!(
+    KEY_ESC, Escape,
+    KEY_1, Num1,
+    KEY_2, Num2,
+    KEY_3, Num3,
+    KEY_4, Num4,
+    KEY_5, Num5,
+    KEY_6, Num6,
+    KEY_7, Num7,
+    KEY_8, Num8,
+    KEY_9, Num9,
+    KEY_0, Num0,
+    KEY_MINUS, Minus,
+    KEY_EQUAL, Equal,
+    KEY_BACKSPACE, Backspace,
+    KEY_TAB, Tab,
+    KEY_Q, KeyQ,
+    KEY_W, KeyW,
+    KEY_E, KeyE,
+    KEY_R, KeyR,
+    KEY_T, KeyT,
+    KEY_Y, KeyY,
+    KEY_U, KeyU,
+    KEY_I, KeyI,
+    KEY_O, KeyO,
+    KEY_P, KeyP,
+    KEY_LEFTBRACE, LeftBracket,
+    KEY_RIGHTBRACE, RightBracket,
+    KEY_ENTER, Return,
+    KEY_LEFTCTRL, ControlLeft,
+    KEY_A, KeyA,
+    KEY_S, KeyS,
+    KEY_D, KeyD,
+    KEY_F, KeyF,
+    KEY_G, KeyG,
+    KEY_H, KeyH,
+    KEY_J, KeyJ,
+    KEY_K, KeyK,
+    KEY_L, KeyL,
+    KEY_SEMICOLON, SemiColon,
+    KEY_APOSTROPHE, Quote,
+    KEY_GRAVE, BackQuote,
+    KEY_LEFTSHIFT, ShiftLeft,
+    KEY_BACKSLASH, BackSlash,
+    KEY_Z, KeyZ,
+    KEY_X, KeyX,
+    KEY_C, KeyC,
+    KEY_V, KeyV,
+    KEY_B, KeyB,
+    KEY_N, KeyN,
+    KEY_M, KeyM,
+    KEY_COMMA, Comma,
+    KEY_DOT, Dot,
+    KEY_SLASH, Slash,
+    KEY_RIGHTSHIFT, ShiftRight,
+    KEY_KPASTERISK , KpMultiply,
+    KEY_LEFTALT, Alt,
+    KEY_SPACE, Space,
+    KEY_CAPSLOCK, CapsLock,
+    KEY_F1, F1,
+    KEY_F2, F2,
+    KEY_F3, F3,
+    KEY_F4, F4,
+    KEY_F5, F5,
+    KEY_F6, F6,
+    KEY_F7, F7,
+    KEY_F8, F8,
+    KEY_F9, F9,
+    KEY_F10, F10,
+    KEY_NUMLOCK, NumLock,
+    KEY_SCROLLLOCK, ScrollLock,
+    KEY_KP7, Kp7,
+    KEY_KP8, Kp8,
+    KEY_KP9, Kp9,
+    KEY_KPMINUS, KpMinus,
+    KEY_KP4, Kp4,
+    KEY_KP5, Kp5,
+    KEY_KP6, Kp6,
+    KEY_KPPLUS, KpPlus,
+    KEY_KP1, Kp1,
+    KEY_KP2, Kp2,
+    KEY_KP3, Kp3,
+    KEY_KP0, Kp0,
+    KEY_F11, F11,
+    KEY_F12, F12,
+    KEY_KPENTER, KpReturn,
+    KEY_RIGHTCTRL, ControlRight,
+    KEY_KPSLASH, KpDivide,
+    KEY_RIGHTALT, AltGr,
+    KEY_HOME , Home,
+    KEY_UP, UpArrow,
+    KEY_PAGEUP, PageUp,
+    KEY_LEFT, LeftArrow,
+    KEY_RIGHT, RightArrow,
+    KEY_END, End,
+    KEY_DOWN, DownArrow,
+    KEY_PAGEDOWN, PageDown,
+    KEY_INSERT, Insert,
+    KEY_DELETE, Delete,
+    KEY_PAUSE, Pause,
+    KEY_LEFTMETA, MetaLeft,
+    KEY_RIGHTMETA, MetaRight,
+    KEY_PRINT, PrintScreen,
+    // KpDelete behaves like normal Delete most of the time
+    KEY_DELETE, KpDelete,
+    // Linux doesn't have an IntlBackslash key
+    KEY_BACKSLASH, IntlBackslash
+);
+
+fn evdev_event_to_rdev_event(
+    event: &InputEvent,
+    x: &mut f64,
+    y: &mut f64,
+    w: f64,
+    h: f64,
+) -> Option<EventType> {
+    match &event.event_code {
+        EventCode::EV_KEY(key) => {
+            if let Some(button) = evdev_key_to_rdev_button(key) {
+                // first check if pressed key is a mouse button
+                match event.value {
+                    0 => Some(EventType::ButtonRelease(button)),
+                    _ => Some(EventType::ButtonPress(button)),
+                }
+            } else if let Some(key) = evdev_key_to_rdev_key(key) {
+                // check if pressed key is a keyboard key
+                match event.value {
+                    0 => Some(EventType::KeyRelease(key)),
+                    _ => Some(EventType::KeyPress(key)),
+                }
+            } else {
+                // if neither mouse button nor keyboard key, return none
+                None
+            }
+        }
+        EventCode::EV_REL(mouse) => match mouse {
+            EV_REL::REL_X => {
+                let dx = event.value as f64;
+                *x += dx;
+                if *x < 0.0 {
+                    *x = 0.0;
+                }
+                if *x > w {
+                    *x = w;
+                }
+                Some(EventType::MouseMove { x: *x, y: *y })
+            }
+            EV_REL::REL_Y => {
+                let dy = event.value as f64;
+                *y += dy;
+                if *y < 0.0 {
+                    *y = 0.0;
+                }
+                if *y > h {
+                    *y = h;
+                }
+                Some(EventType::MouseMove { x: *x, y: *y })
+            }
+            EV_REL::REL_HWHEEL => Some(EventType::Wheel {
+                delta_x: event.value.into(),
+                delta_y: 0,
+            }),
+            EV_REL::REL_WHEEL => Some(EventType::Wheel {
+                delta_x: 0,
+                delta_y: event.value.into(),
+            }),
+            // Other EV_REL events cannot be represented by rdev
+            _ => None,
+        },
+        // Other event_codes cannot be represented by rdev,
+        // and some never will e.g. EV_SYN
+        _ => None,
+    }
+}
+
+// fn rdev_event_to_evdev_event(event: &EventType, time: &TimeVal) -> Option<InputEvent> {
+//     match event {
+//         EventType::KeyPress(key) => {
+//             let key = rdev_key_to_evdev_key(&key)?;
+//             Some(InputEvent::new(&time, &EventCode::EV_KEY(key), 1))
+//         }
+//         EventType::KeyRelease(key) => {
+//             let key = rdev_key_to_evdev_key(&key)?;
+//             Some(InputEvent::new(&time, &EventCode::EV_KEY(key), 0))
+//         }
+//         EventType::ButtonPress(button) => {
+//             let button = rdev_button_to_evdev_key(&button)?;
+//             Some(InputEvent::new(&time, &EventCode::EV_KEY(button), 1))
+//         }
+//         EventType::ButtonRelease(button) => {
+//             let button = rdev_button_to_evdev_key(&button)?;
+//             Some(InputEvent::new(&time, &EventCode::EV_KEY(button), 0))
+//         }
+//         EventType::MouseMove { x, y } => {
+//             let (x, y) = (*x as i32, *y as i32);
+//             //TODO allow both x and y movements simultaneously
+//             if x != 0 {
+//                 Some(InputEvent::new(&time, &EventCode::EV_REL(EV_REL::REL_X), x))
+//             } else {
+//                 Some(InputEvent::new(&time, &EventCode::EV_REL(EV_REL::REL_Y), y))
+//             }
+//         }
+//         EventType::Wheel { delta_x, delta_y } => {
+//             let (x, y) = (*delta_x as i32, *delta_y as i32);
+//             //TODO allow both x and y movements simultaneously
+//             if x != 0 {
+//                 Some(InputEvent::new(
+//                     &time,
+//                     &EventCode::EV_REL(EV_REL::REL_HWHEEL),
+//                     x,
+//                 ))
+//             } else {
+//                 Some(InputEvent::new(
+//                     &time,
+//                     &EventCode::EV_REL(EV_REL::REL_WHEEL),
+//                     y,
+//                 ))
+//             }
+//         }
+//     }
+// }
+
+pub fn grab<T>(callback: T) -> Result<(), GrabError>
+where
+    T: Fn(Event) -> Option<Event> + 'static,
+{
+    let mut kb = Keyboard::new().ok_or(GrabError::KeyboardError)?;
+    let display = Display::new().ok_or(GrabError::MissingDisplayError)?;
+    let (width, height) = display.get_size().ok_or(GrabError::MissingDisplayError)?;
+    let (current_x, current_y) = display
+        .get_mouse_pos()
+        .ok_or(GrabError::MissingDisplayError)?;
+    let mut x = current_x as f64;
+    let mut y = current_y as f64;
+    let w = width as f64;
+    let h = height as f64;
+    filter_map_events(|event| {
+        let event_type = match evdev_event_to_rdev_event(&event, &mut x, &mut y, w, h) {
+            Some(rdev_event) => rdev_event,
+            // If we can't convert event, simulate it
+            None => return (Some(event), GrabStatus::Continue),
+        };
+        let name = kb.add(&event_type);
+        let rdev_event = Event {
+            time: SystemTime::now(),
+            name,
+            event_type,
+        };
+        if callback(rdev_event).is_some() {
+            (Some(event), GrabStatus::Continue)
+        } else {
+            // callback returns None, swallow the event
+            (None, GrabStatus::Continue)
+        }
+    })?;
+    Ok(())
+}
+
+pub fn filter_map_events<F>(mut func: F) -> io::Result<()>
+where
+    F: FnMut(InputEvent) -> (Option<InputEvent>, GrabStatus),
+{
+    let (epoll_fd, mut devices, output_devices) = setup_devices()?;
+    let mut inotify = setup_inotify(epoll_fd, &devices)?;
+
+    //grab devices
+    devices
+        .iter_mut()
+        .try_for_each(|device| device.grab(evdev_rs::GrabMode::Grab))?;
+
+    // create buffer for epoll to fill
+    let mut epoll_buffer = [epoll::Event::new(epoll::Events::empty(), 0); 4];
+    let mut inotify_buffer = vec![0_u8; 4096];
+    'event_loop: loop {
+        let num_events = epoll::wait(epoll_fd, -1, &mut epoll_buffer)?;
+
+        //map and simulate events, dealing with
+        'events: for event in &epoll_buffer[0..num_events] {
+            // new device file created
+            if event.data == INOTIFY_DATA {
+                for event in inotify.read_events(&mut inotify_buffer)? {
+                    assert!(
+                        event.mask.contains(inotify::EventMask::CREATE),
+                        "inotify is listening for events other than file creation"
+                    );
+                    add_device_to_epoll_from_inotify_event(epoll_fd, event, &mut devices)?;
+                }
+            } else {
+                // Input device recieved event
+                let device_idx = event.data as usize;
+                let device = devices.get(device_idx).unwrap();
+                while device.has_event_pending() {
+                    //TODO: deal with EV_SYN::SYN_DROPPED
+                    let (_, event) = match device.next_event(evdev_rs::ReadFlag::NORMAL) {
+                        Ok(event) => event,
+                        Err(_) => {
+                            let device_fd = device.fd().unwrap().into_raw_fd();
+                            let empty_event = epoll::Event::new(epoll::Events::empty(), 0);
+                            epoll::ctl(epoll_fd, EPOLL_CTL_DEL, device_fd, empty_event)?;
+                            continue 'events;
+                        }
+                    };
+                    let (event, grab_status) = func(event);
+
+                    if let (Some(event), Some(out_device)) = (event, output_devices.get(device_idx))
+                    {
+                        out_device.write_event(&event)?;
+                    }
+                    if grab_status == GrabStatus::Stop {
+                        break 'event_loop;
+                    }
+                }
+            }
+        }
+    }
+
+    for device in devices.iter_mut() {
+        //ungrab devices, ignore errors
+        device.grab(evdev_rs::GrabMode::Ungrab).ok();
+    }
+
+    epoll::close(epoll_fd)?;
+    Ok(())
+}
+
+static DEV_PATH: &str = "/dev/input";
+const INOTIFY_DATA: u64 = u64::max_value();
+const EPOLLIN: epoll::Events = epoll::Events::EPOLLIN;
+
+/// Whether to continue grabbing events or to stop
+/// Used in `filter_map_events` (and others)
+#[derive(Debug, Eq, PartialEq, Hash)]
+pub enum GrabStatus {
+    /// Stop grabbing
+    Continue,
+    /// ungrab events
+    Stop,
+}
+
+fn get_device_files<T>(path: T) -> io::Result<Vec<File>>
+where
+    T: AsRef<Path>,
+{
+    let mut res = Vec::new();
+    for entry in read_dir(path)? {
+        let entry = entry?;
+        // /dev/input files are character devices
+        if !entry.file_type()?.is_char_device() {
+            continue;
+        }
+
+        let path = entry.path();
+        let file_name_bytes = match path.file_name() {
+            Some(file_name) => file_name.as_bytes(),
+            None => continue, // file_name was "..", should be impossible
+        };
+        // skip filenames matching "mouse.* or mice".
+        // these files don't play nice with libevdev, not sure why
+        // see: https://askubuntu.com/questions/1043832/difference-between-dev-input-mouse0-and-dev-input-mice
+        if file_name_bytes == OsStr::new("mice").as_bytes()
+            || file_name_bytes
+                .get(0..=1)
+                .map(|s| s == OsStr::new("js").as_bytes())
+                .unwrap_or(false)
+            || file_name_bytes
+                .get(0..=4)
+                .map(|s| s == OsStr::new("mouse").as_bytes())
+                .unwrap_or(false)
+        {
+            continue;
+        }
+        res.push(File::open(path)?);
+    }
+    Ok(res)
+}
+
+fn epoll_watch_all<'a, T>(device_files: T) -> io::Result<RawFd>
+where
+    T: Iterator<Item = &'a File>,
+{
+    let epoll_fd = epoll::create(true)?;
+    // add file descriptors to epoll
+    for (file_idx, file) in device_files.enumerate() {
+        let epoll_event = epoll::Event::new(EPOLLIN, file_idx as u64);
+        epoll::ctl(epoll_fd, EPOLL_CTL_ADD, file.as_raw_fd(), epoll_event)?;
+    }
+    Ok(epoll_fd)
+}
+
+fn inotify_devices() -> io::Result<Inotify> {
+    let mut inotify = Inotify::init()?;
+    inotify.add_watch(DEV_PATH, WatchMask::CREATE)?;
+    Ok(inotify)
+}
+
+fn add_device_to_epoll_from_inotify_event(
+    epoll_fd: RawFd,
+    event: inotify::Event<&OsStr>,
+    devices: &mut Vec<Device>,
+) -> io::Result<()> {
+    let mut device_path = OsString::from(DEV_PATH);
+    device_path.push(OsString::from("/"));
+    device_path.push(event.name.unwrap());
+    // new plug events
+    let file = File::open(device_path)?;
+    let fd = file.as_raw_fd();
+    let device = Device::new_from_fd(file)?;
+    let event = epoll::Event::new(EPOLLIN, devices.len() as u64);
+    devices.push(device);
+    epoll::ctl(epoll_fd, EPOLL_CTL_ADD, fd, event)?;
+    Ok(())
+}
+
+/// Returns tuple of epoll_fd, all devices, and uinput devices, where
+/// uinputdevices is the same length as devices, and each uinput device is
+/// a libevdev copy of its corresponding device.The epoll_fd is level-triggered
+/// on any available data in the original devices.
+fn setup_devices() -> io::Result<(RawFd, Vec<Device>, Vec<UInputDevice>)> {
+    let device_files = get_device_files(DEV_PATH)?;
+    let epoll_fd = epoll_watch_all(device_files.iter())?;
+    let devices = device_files
+        .into_iter()
+        .map(Device::new_from_fd)
+        .collect::<io::Result<Vec<Device>>>()?;
+    let output_devices = devices
+        .iter()
+        .map(UInputDevice::create_from_device)
+        .collect::<io::Result<Vec<UInputDevice>>>()?;
+    Ok((epoll_fd, devices, output_devices))
+}
+
+/// Creates an inotify instance looking at /dev/input and adds it to an epoll instance.
+/// Ensures devices isnt too long, which would make the epoll data ambigious.
+fn setup_inotify(epoll_fd: RawFd, devices: &[Device]) -> io::Result<Inotify> {
+    //Ensure there is space for inotify at last epoll index.
+    if devices.len() as u64 >= INOTIFY_DATA {
+        eprintln!("number of devices: {}", devices.len());
+        return Err(io::Error::new(
+            io::ErrorKind::Other,
+            "too many device files!",
+        ));
+    }
+    // Set up inotify to listen for new devices being plugged in
+    let inotify = inotify_devices()?;
+    let epoll_event = epoll::Event::new(EPOLLIN, INOTIFY_DATA);
+    epoll::ctl(epoll_fd, EPOLL_CTL_ADD, inotify.as_raw_fd(), epoll_event)?;
+    Ok(inotify)
+}
diff --git a/src/linux/keyboard.rs b/src/linux/keyboard.rs
new file mode 100644
index 0000000..0ac7181
--- /dev/null
+++ b/src/linux/keyboard.rs
@@ -0,0 +1,269 @@
+extern crate x11;
+use crate::linux::keycodes::code_from_key;
+use crate::rdev::{EventType, Key, KeyboardState};
+use std::ffi::CString;
+use std::os::raw::{c_char, c_int, c_uint, c_ulong, c_void};
+use std::ptr::{null, null_mut, NonNull};
+use x11::xlib;
+
+#[derive(Debug)]
+struct State {
+    alt: bool,
+    ctrl: bool,
+    caps_lock: bool,
+    shift: bool,
+    meta: bool,
+}
+
+// Inspired from https://github.com/wavexx/screenkey
+// But without remitting events to custom windows, instead we recreate  XKeyEvent
+// from xEvent data received via xrecord.
+// Other source of inspiration https://gist.github.com/baines/5a49f1334281b2685af5dcae81a6fa8a
+// Needed xproto crate as x11 does not implement _xevent.
+impl State {
+    fn new() -> State {
+        State {
+            alt: false,
+            ctrl: false,
+            caps_lock: false,
+            meta: false,
+            shift: false,
+        }
+    }
+
+    fn value(&self) -> c_uint {
+        let mut res: c_uint = 0;
+        if self.alt {
+            res += xlib::Mod1Mask;
+        }
+        if self.ctrl {
+            res += xlib::ControlMask;
+        }
+        if self.caps_lock {
+            res += xlib::LockMask;
+        }
+        if self.meta {
+            res += xlib::Mod4Mask;
+        }
+        if self.shift {
+            res += xlib::ShiftMask;
+        }
+        res
+    }
+}
+
+#[derive(Debug)]
+pub struct Keyboard {
+    pub xim: Box<xlib::XIM>,
+    pub xic: Box<xlib::XIC>,
+    pub display: Box<*mut xlib::Display>,
+    window: Box<xlib::Window>,
+    keysym: Box<c_ulong>,
+    status: Box<i32>,
+    state: State,
+    serial: c_ulong,
+}
+impl Drop for Keyboard {
+    fn drop(&mut self) {
+        unsafe {
+            xlib::XCloseDisplay(*self.display);
+        }
+    }
+}
+
+impl Keyboard {
+    pub fn new() -> Option<Keyboard> {
+        unsafe {
+            // https://stackoverflow.com/questions/18246848/get-utf-8-input-with-x11-display#
+            let string = CString::new("@im=none").expect("Can't creat CString");
+            let ret = xlib::XSetLocaleModifiers(string.as_ptr());
+            NonNull::new(ret)?;
+
+            let dpy = xlib::XOpenDisplay(null());
+            if dpy.is_null() {
+                return None;
+            }
+            let xim = xlib::XOpenIM(dpy, null_mut(), null_mut(), null_mut());
+            NonNull::new(xim)?;
+
+            let mut win_attr = xlib::XSetWindowAttributes {
+                background_pixel: 0,
+                background_pixmap: 0,
+                border_pixel: 0,
+                border_pixmap: 0,
+                bit_gravity: 0,
+                win_gravity: 0,
+                backing_store: 0,
+                backing_planes: 0,
+                backing_pixel: 0,
+                event_mask: 0,
+                save_under: 0,
+                do_not_propagate_mask: 0,
+                override_redirect: 0,
+                colormap: 0,
+                cursor: 0,
+            };
+
+            let window = xlib::XCreateWindow(
+                dpy,
+                xlib::XDefaultRootWindow(dpy),
+                0,
+                0,
+                1,
+                1,
+                0,
+                xlib::CopyFromParent,
+                xlib::InputOnly as c_uint,
+                null_mut(),
+                xlib::CWOverrideRedirect,
+                &mut win_attr,
+            );
+
+            let input_style = CString::new(xlib::XNInputStyle).expect("CString::new failed");
+            let window_client = CString::new(xlib::XNClientWindow).expect("CString::new failed");
+            let style = xlib::XIMPreeditNothing | xlib::XIMStatusNothing;
+
+            let xic = xlib::XCreateIC(
+                xim,
+                window_client.as_ptr(),
+                window,
+                input_style.as_ptr(),
+                style,
+                null::<c_void>(),
+            );
+            NonNull::new(xic)?;
+            xlib::XSetICFocus(xic);
+            Some(Keyboard {
+                xim: Box::new(xim),
+                xic: Box::new(xic),
+                display: Box::new(dpy),
+                window: Box::new(window),
+                keysym: Box::new(0),
+                status: Box::new(0),
+                state: State::new(),
+                serial: 0,
+            })
+        }
+    }
+
+    pub(crate) unsafe fn name_from_code(
+        &mut self,
+        keycode: c_uint,
+        state: c_uint,
+    ) -> Option<String> {
+        if self.display.is_null() || self.xic.is_null() {
+            println!("We don't seem to have a display or a xic");
+            return None;
+        }
+        const BUF_LEN: usize = 4;
+        let mut buf = [0_u8; BUF_LEN];
+        let key = xlib::XKeyEvent {
+            display: *self.display,
+            root: 0,
+            window: *self.window,
+            subwindow: 0,
+            x: 0,
+            y: 0,
+            x_root: 0,
+            y_root: 0,
+            state,
+            keycode,
+            same_screen: 0,
+            send_event: 0,
+            serial: self.serial,
+            type_: xlib::KeyPress,
+            time: xlib::CurrentTime,
+        };
+        self.serial += 1;
+
+        let mut event = xlib::XEvent { key };
+
+        // -----------------------------------------------------------------
+        // XXX: This is **OMEGA IMPORTANT** This is what enables us to receive
+        // the correct keyvalue from the utf8LookupString !!
+        // https://stackoverflow.com/questions/18246848/get-utf-8-input-with-x11-display#
+        // -----------------------------------------------------------------
+        xlib::XFilterEvent(&mut event, 0);
+
+        let ret = xlib::Xutf8LookupString(
+            *self.xic,
+            &mut event.key,
+            buf.as_mut_ptr() as *mut c_char,
+            BUF_LEN as c_int,
+            &mut *self.keysym,
+            &mut *self.status,
+        );
+        if ret == xlib::NoSymbol {
+            return None;
+        }
+
+        let len = buf.iter().position(|ch| ch == &0).unwrap_or(BUF_LEN);
+        String::from_utf8(buf[..len].to_vec()).ok()
+    }
+}
+
+impl KeyboardState for Keyboard {
+    fn add(&mut self, event_type: &EventType) -> Option<String> {
+        match event_type {
+            EventType::KeyPress(key) => match key {
+                Key::ShiftLeft | Key::ShiftRight => {
+                    self.state.shift = true;
+                    None
+                }
+                Key::CapsLock => {
+                    self.state.caps_lock = !self.state.caps_lock;
+                    None
+                }
+                key => {
+                    let keycode = code_from_key(*key)?;
+                    let state = self.state.value();
+                    unsafe { self.name_from_code(keycode, state) }
+                }
+            },
+            EventType::KeyRelease(key) => match key {
+                Key::ShiftLeft | Key::ShiftRight => {
+                    self.state.shift = false;
+                    None
+                }
+                _ => None,
+            },
+            _ => None,
+        }
+    }
+    fn reset(&mut self) {
+        self.state = State::new();
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    #[ignore]
+    /// If the following tests run, they *will* cause a crash because xlib
+    /// is *not* thread safe. Ignoring the tests for now.
+    /// XCB *could* be an option but not even sure we can get dead keys again.
+    /// XCB doc is sparse on the web let's say.
+    fn test_thread_safety() {
+        let mut keyboard = Keyboard::new().unwrap();
+        let char_s = keyboard.add(&EventType::KeyPress(Key::KeyS)).unwrap();
+        assert_eq!(
+            char_s,
+            "s".to_string(),
+            "This test should pass only on Qwerty layout !"
+        );
+    }
+
+    #[test]
+    #[ignore]
+    fn test_thread_safety_2() {
+        let mut keyboard = Keyboard::new().unwrap();
+        let char_s = keyboard.add(&EventType::KeyPress(Key::KeyS)).unwrap();
+        assert_eq!(
+            char_s,
+            "s".to_string(),
+            "This test should pass only on Qwerty layout !"
+        );
+    }
+}
diff --git a/src/linux/keycodes.rs b/src/linux/keycodes.rs
new file mode 100644
index 0000000..85adecf
--- /dev/null
+++ b/src/linux/keycodes.rs
@@ -0,0 +1,149 @@
+use crate::rdev::Key;
+use std::os::raw::c_uint;
+
+macro_rules! decl_keycodes {
+    ($($key:ident, $code:literal),*) => {
+        //TODO: make const when rust lang issue #49146 is fixed
+        pub fn code_from_key(key: Key) -> Option<c_uint> {
+            match key {
+                $(
+                    Key::$key => Some($code),
+                )*
+                Key::Unknown(code) => Some(code),
+                _ => None,
+            }
+        }
+
+        //TODO: make const when rust lang issue #49146 is fixed
+        pub fn key_from_code(code: c_uint) -> Key {
+            match code {
+                $(
+                    $code => Key::$key,
+                )*
+                _ => Key::Unknown(code)
+            }
+        }
+    };
+}
+
+#[rustfmt::skip]
+decl_keycodes!(
+    Alt, 64,
+    AltGr, 108,
+    Backspace, 22,
+    CapsLock, 66,
+    ControlLeft, 37,
+    ControlRight, 105,
+    Delete, 119,
+    DownArrow, 116,
+    End, 115,
+    Escape, 9,
+    F1, 67,
+    F10, 76,
+    F11, 95,
+    F12, 96,
+    F2, 68,
+    F3, 69,
+    F4, 70,
+    F5, 71,
+    F6, 72,
+    F7, 73,
+    F8, 74,
+    F9, 75,
+    Home, 110,
+    LeftArrow, 113,
+    MetaLeft, 133,
+    PageDown, 117,
+    PageUp, 112,
+    Return, 36,
+    RightArrow, 114,
+    ShiftLeft, 50,
+    ShiftRight, 62,
+    Space, 65,
+    Tab, 23,
+    UpArrow, 111,
+    PrintScreen, 107,
+    ScrollLock, 78,
+    Pause, 127,
+    NumLock, 77,
+    BackQuote, 49,
+    Num1, 10,
+    Num2, 11,
+    Num3, 12,
+    Num4, 13,
+    Num5, 14,
+    Num6, 15,
+    Num7, 16,
+    Num8, 17,
+    Num9, 18,
+    Num0, 19,
+    Minus, 20,
+    Equal, 21,
+    KeyQ, 24,
+    KeyW, 25,
+    KeyE, 26,
+    KeyR, 27,
+    KeyT, 28,
+    KeyY, 29,
+    KeyU, 30,
+    KeyI, 31,
+    KeyO, 32,
+    KeyP, 33,
+    LeftBracket, 34,
+    RightBracket, 35,
+    KeyA, 38,
+    KeyS, 39,
+    KeyD, 40,
+    KeyF, 41,
+    KeyG, 42,
+    KeyH, 43,
+    KeyJ, 44,
+    KeyK, 45,
+    KeyL, 46,
+    SemiColon, 47,
+    Quote, 48,
+    BackSlash, 51,
+    IntlBackslash, 94,
+    KeyZ, 52,
+    KeyX, 53,
+    KeyC, 54,
+    KeyV, 55,
+    KeyB, 56,
+    KeyN, 57,
+    KeyM, 58,
+    Comma, 59,
+    Dot, 60,
+    Slash, 61,
+    Insert, 118,
+    KpReturn, 104,
+    KpMinus, 82,
+    KpPlus, 86,
+    KpMultiply, 63,
+    KpDivide, 106,
+    Kp0, 90,
+    Kp1, 87,
+    Kp2, 88,
+    Kp3, 89,
+    Kp4, 83,
+    Kp5, 84,
+    Kp6, 85,
+    Kp7, 79,
+    Kp8, 80,
+    Kp9, 81,
+    KpDelete, 91
+);
+
+#[cfg(test)]
+mod test {
+    use super::{code_from_key, key_from_code};
+    #[test]
+    fn test_reversible() {
+        for code in 0..65636 {
+            let key = key_from_code(code);
+            match code_from_key(key) {
+                Some(code2) => assert_eq!(code, code2),
+                None => panic!("Could not convert back code: {:?}", code),
+            }
+        }
+    }
+}
diff --git a/src/linux/listen.rs b/src/linux/listen.rs
new file mode 100644
index 0000000..dac0cd8
--- /dev/null
+++ b/src/linux/listen.rs
@@ -0,0 +1,114 @@
+extern crate libc;
+extern crate x11;
+use crate::linux::common::{convert, FALSE, KEYBOARD};
+use crate::linux::keyboard::Keyboard;
+use crate::rdev::{Event, ListenError};
+use std::convert::TryInto;
+use std::ffi::CStr;
+use std::os::raw::{c_char, c_int, c_uchar, c_uint, c_ulong};
+use std::ptr::null;
+use x11::xlib;
+use x11::xrecord;
+
+static mut RECORD_ALL_CLIENTS: c_ulong = xrecord::XRecordAllClients;
+static mut GLOBAL_CALLBACK: Option<Box<dyn FnMut(Event)>> = None;
+
+pub fn listen<T>(callback: T) -> Result<(), ListenError>
+where
+    T: FnMut(Event) + 'static,
+{
+    let keyboard = Keyboard::new().ok_or(ListenError::KeyboardError)?;
+
+    unsafe {
+        KEYBOARD = Some(keyboard);
+        GLOBAL_CALLBACK = Some(Box::new(callback));
+        // Open displays
+        let dpy_control = xlib::XOpenDisplay(null());
+        if dpy_control.is_null() {
+            return Err(ListenError::MissingDisplayError);
+        }
+        let extension_name = CStr::from_bytes_with_nul(b"RECORD\0")
+            .map_err(|_| ListenError::XRecordExtensionError)?;
+        let extension = xlib::XInitExtension(dpy_control, extension_name.as_ptr());
+        if extension.is_null() {
+            return Err(ListenError::XRecordExtensionError);
+        }
+
+        // Prepare record range
+        let mut record_range: xrecord::XRecordRange = *xrecord::XRecordAllocRange();
+        record_range.device_events.first = xlib::KeyPress as c_uchar;
+        record_range.device_events.last = xlib::MotionNotify as c_uchar;
+
+        // Create context
+        let context = xrecord::XRecordCreateContext(
+            dpy_control,
+            0,
+            &mut RECORD_ALL_CLIENTS,
+            1,
+            &mut &mut record_range as *mut &mut xrecord::XRecordRange
+                as *mut *mut xrecord::XRecordRange,
+            1,
+        );
+
+        if context == 0 {
+            return Err(ListenError::RecordContextError);
+        }
+
+        xlib::XSync(dpy_control, FALSE);
+        // Run
+        let result =
+            xrecord::XRecordEnableContext(dpy_control, context, Some(record_callback), &mut 0);
+        if result == 0 {
+            return Err(ListenError::RecordContextEnablingError);
+        }
+    }
+    Ok(())
+}
+
+// No idea how to do that properly relevant doc lives here:
+// https://www.x.org/releases/X11R7.7/doc/libXtst/recordlib.html#Datum_Flags
+// https://docs.rs/xproto/1.1.5/xproto/struct._xEvent__bindgen_ty_1.html
+// 0.4.2: xproto was removed for some reason and contained the real structs
+// but we can't use it anymore.
+#[repr(C)]
+struct XRecordDatum {
+    type_: u8,
+    code: u8,
+    _rest: u64,
+    _1: bool,
+    _2: bool,
+    _3: bool,
+    root_x: i16,
+    root_y: i16,
+    event_x: i16,
+    event_y: i16,
+    state: u16,
+}
+
+unsafe extern "C" fn record_callback(
+    _null: *mut c_char,
+    raw_data: *mut xrecord::XRecordInterceptData,
+) {
+    let data = raw_data.as_ref().unwrap();
+    if data.category != xrecord::XRecordFromServer {
+        return;
+    }
+
+    debug_assert!(data.data_len * 4 >= std::mem::size_of::<XRecordDatum>().try_into().unwrap());
+    // Cast binary data
+    #[allow(clippy::cast_ptr_alignment)]
+    let xdatum = (data.data as *const XRecordDatum).as_ref().unwrap();
+
+    let code: c_uint = xdatum.code.into();
+    let type_: c_int = xdatum.type_.into();
+
+    let x = xdatum.root_x as f64;
+    let y = xdatum.root_y as f64;
+
+    if let Some(event) = convert(&mut KEYBOARD, code, type_, x, y) {
+        if let Some(callback) = &mut GLOBAL_CALLBACK {
+            callback(event);
+        }
+    }
+    xrecord::XRecordFreeData(raw_data);
+}
diff --git a/src/linux/mod.rs b/src/linux/mod.rs
new file mode 100644
index 0000000..bda3776
--- /dev/null
+++ b/src/linux/mod.rs
@@ -0,0 +1,19 @@
+extern crate libc;
+extern crate x11;
+
+mod common;
+mod display;
+#[cfg(feature = "unstable_grab")]
+mod grab;
+mod keyboard;
+mod keycodes;
+mod listen;
+mod simulate;
+
+pub use crate::linux::keycodes::{key_from_code, code_from_key};
+pub use crate::linux::display::display_size;
+#[cfg(feature = "unstable_grab")]
+pub use crate::linux::grab::grab;
+pub use crate::linux::keyboard::Keyboard;
+pub use crate::linux::listen::listen;
+pub use crate::linux::simulate::simulate;
diff --git a/src/linux/simulate.rs b/src/linux/simulate.rs
new file mode 100644
index 0000000..8fa3b53
--- /dev/null
+++ b/src/linux/simulate.rs
@@ -0,0 +1,99 @@
+use crate::linux::common::{FALSE, TRUE};
+use crate::linux::keycodes::code_from_key;
+use crate::rdev::{Button, EventType, SimulateError};
+use std::convert::TryInto;
+use std::os::raw::c_int;
+use std::ptr::null;
+use x11::xlib;
+use x11::xtest;
+
+unsafe fn send_native(event_type: &EventType, display: *mut xlib::Display) -> Option<()> {
+    let res = match event_type {
+        EventType::KeyPress(key) => {
+            let code = code_from_key(*key)?;
+            xtest::XTestFakeKeyEvent(display, code, TRUE, 0)
+        }
+        EventType::KeyRelease(key) => {
+            let code = code_from_key(*key)?;
+            xtest::XTestFakeKeyEvent(display, code, FALSE, 0)
+        }
+        EventType::ButtonPress(button) => match button {
+            Button::Left => xtest::XTestFakeButtonEvent(display, 1, TRUE, 0),
+            Button::Middle => xtest::XTestFakeButtonEvent(display, 2, TRUE, 0),
+            Button::Right => xtest::XTestFakeButtonEvent(display, 3, TRUE, 0),
+            Button::Unknown(code) => {
+                xtest::XTestFakeButtonEvent(display, (*code).try_into().ok()?, TRUE, 0)
+            }
+        },
+        EventType::ButtonRelease(button) => match button {
+            Button::Left => xtest::XTestFakeButtonEvent(display, 1, FALSE, 0),
+            Button::Middle => xtest::XTestFakeButtonEvent(display, 2, FALSE, 0),
+            Button::Right => xtest::XTestFakeButtonEvent(display, 3, FALSE, 0),
+            Button::Unknown(code) => {
+                xtest::XTestFakeButtonEvent(display, (*code).try_into().ok()?, FALSE, 0)
+            }
+        },
+        EventType::MouseMove { x, y } => {
+            //TODO: replace with clamp if it is stabalized
+            let x = if x.is_finite() {
+                x.min(c_int::max_value().into())
+                    .max(c_int::min_value().into())
+                    .round() as c_int
+            } else {
+                0
+            };
+            let y = if y.is_finite() {
+                y.min(c_int::max_value().into())
+                    .max(c_int::min_value().into())
+                    .round() as c_int
+            } else {
+                0
+            };
+            xtest::XTestFakeMotionEvent(display, 0, x, y, 0)
+            //     xlib::XWarpPointer(display, 0, root, 0, 0, 0, 0, *x as i32, *y as i32);
+        }
+        EventType::Wheel { delta_x, delta_y } => {
+            let code_x = if *delta_x > 0 { 7 } else { 6 };
+            let code_y = if *delta_y > 0 { 4 } else { 5 };
+
+            let mut result: c_int = 1;
+            for _ in 0..delta_x.abs() {
+                result = result
+                    & xtest::XTestFakeButtonEvent(display, code_x, TRUE, 0)
+                    & xtest::XTestFakeButtonEvent(display, code_x, FALSE, 0)
+            }
+            for _ in 0..delta_y.abs() {
+                result = result
+                    & xtest::XTestFakeButtonEvent(display, code_y, TRUE, 0)
+                    & xtest::XTestFakeButtonEvent(display, code_y, FALSE, 0)
+            }
+            result
+        }
+    };
+    if res == 0 {
+        None
+    } else {
+        Some(())
+    }
+}
+
+pub fn simulate(event_type: &EventType) -> Result<(), SimulateError> {
+    unsafe {
+        let dpy = xlib::XOpenDisplay(null());
+        if dpy.is_null() {
+            return Err(SimulateError);
+        }
+        match send_native(event_type, dpy) {
+            Some(_) => {
+                xlib::XFlush(dpy);
+                xlib::XSync(dpy, 0);
+                xlib::XCloseDisplay(dpy);
+                Ok(())
+            }
+            None => {
+                xlib::XCloseDisplay(dpy);
+                Err(SimulateError)
+            }
+        }
+    }
+}
diff --git a/src/macos/common.rs b/src/macos/common.rs
new file mode 100644
index 0000000..16c0371
--- /dev/null
+++ b/src/macos/common.rs
@@ -0,0 +1,152 @@
+#![allow(clippy::upper_case_acronyms)]
+use crate::macos::keyboard::Keyboard;
+use crate::rdev::{Button, Event, EventType};
+use cocoa::base::id;
+use core_graphics::event::{CGEvent, CGEventFlags, CGEventTapLocation, CGEventType, EventField};
+use lazy_static::lazy_static;
+use std::convert::TryInto;
+use std::os::raw::c_void;
+use std::sync::Mutex;
+use std::time::SystemTime;
+
+use crate::macos::keycodes::key_from_code;
+
+pub type CFMachPortRef = *const c_void;
+pub type CFIndex = u64;
+pub type CFAllocatorRef = id;
+pub type CFRunLoopSourceRef = id;
+pub type CFRunLoopRef = id;
+pub type CFRunLoopMode = id;
+pub type CGEventTapProxy = id;
+pub type CGEventRef = CGEvent;
+
+// https://developer.apple.com/documentation/coregraphics/cgeventtapplacement?language=objc
+pub type CGEventTapPlacement = u32;
+#[allow(non_upper_case_globals)]
+pub const kCGHeadInsertEventTap: u32 = 0;
+
+// https://developer.apple.com/documentation/coregraphics/cgeventtapoptions?language=objc
+#[allow(non_upper_case_globals)]
+#[repr(u32)]
+pub enum CGEventTapOption {
+    #[cfg(feature = "unstable_grab")]
+    Default = 0,
+    ListenOnly = 1,
+}
+
+pub static mut LAST_FLAGS: CGEventFlags = CGEventFlags::CGEventFlagNull;
+lazy_static! {
+    pub static ref KEYBOARD_STATE: Mutex<Keyboard> = Mutex::new(Keyboard::new().unwrap());
+}
+
+// https://developer.apple.com/documentation/coregraphics/cgeventmask?language=objc
+pub type CGEventMask = u64;
+#[allow(non_upper_case_globals)]
+pub const kCGEventMaskForAllEvents: u64 = (1 << CGEventType::LeftMouseDown as u64)
+    + (1 << CGEventType::LeftMouseUp as u64)
+    + (1 << CGEventType::RightMouseDown as u64)
+    + (1 << CGEventType::RightMouseUp as u64)
+    + (1 << CGEventType::MouseMoved as u64)
+    + (1 << CGEventType::LeftMouseDragged as u64)
+    + (1 << CGEventType::RightMouseDragged as u64)
+    + (1 << CGEventType::KeyDown as u64)
+    + (1 << CGEventType::KeyUp as u64)
+    + (1 << CGEventType::FlagsChanged as u64)
+    + (1 << CGEventType::ScrollWheel as u64);
+
+#[cfg(target_os = "macos")]
+#[link(name = "Cocoa", kind = "framework")]
+extern "C" {
+    #[allow(improper_ctypes)]
+    pub fn CGEventTapCreate(
+        tap: CGEventTapLocation,
+        place: CGEventTapPlacement,
+        options: CGEventTapOption,
+        eventsOfInterest: CGEventMask,
+        callback: QCallback,
+        user_info: id,
+    ) -> CFMachPortRef;
+    pub fn CFMachPortCreateRunLoopSource(
+        allocator: CFAllocatorRef,
+        tap: CFMachPortRef,
+        order: CFIndex,
+    ) -> CFRunLoopSourceRef;
+    pub fn CFRunLoopAddSource(rl: CFRunLoopRef, source: CFRunLoopSourceRef, mode: CFRunLoopMode);
+    pub fn CFRunLoopGetCurrent() -> CFRunLoopRef;
+    pub fn CGEventTapEnable(tap: CFMachPortRef, enable: bool);
+    pub fn CFRunLoopRun();
+
+    pub static kCFRunLoopCommonModes: CFRunLoopMode;
+
+}
+pub type QCallback = unsafe extern "C" fn(
+    proxy: CGEventTapProxy,
+    _type: CGEventType,
+    cg_event: CGEventRef,
+    user_info: *mut c_void,
+) -> CGEventRef;
+
+pub unsafe fn convert(
+    _type: CGEventType,
+    cg_event: &CGEvent,
+    keyboard_state: &mut Keyboard,
+) -> Option<Event> {
+    let option_type = match _type {
+        CGEventType::LeftMouseDown => Some(EventType::ButtonPress(Button::Left)),
+        CGEventType::LeftMouseUp => Some(EventType::ButtonRelease(Button::Left)),
+        CGEventType::RightMouseDown => Some(EventType::ButtonPress(Button::Right)),
+        CGEventType::RightMouseUp => Some(EventType::ButtonRelease(Button::Right)),
+        CGEventType::MouseMoved => {
+            let point = cg_event.location();
+            Some(EventType::MouseMove {
+                x: point.x,
+                y: point.y,
+            })
+        }
+        CGEventType::KeyDown => {
+            let code = cg_event.get_integer_value_field(EventField::KEYBOARD_EVENT_KEYCODE);
+            Some(EventType::KeyPress(key_from_code(code.try_into().ok()?)))
+        }
+        CGEventType::KeyUp => {
+            let code = cg_event.get_integer_value_field(EventField::KEYBOARD_EVENT_KEYCODE);
+            Some(EventType::KeyRelease(key_from_code(code.try_into().ok()?)))
+        }
+        CGEventType::FlagsChanged => {
+            let code = cg_event.get_integer_value_field(EventField::KEYBOARD_EVENT_KEYCODE);
+            let code = code.try_into().ok()?;
+            let flags = cg_event.get_flags();
+            if flags < LAST_FLAGS {
+                LAST_FLAGS = flags;
+                Some(EventType::KeyRelease(key_from_code(code)))
+            } else {
+                LAST_FLAGS = flags;
+                Some(EventType::KeyPress(key_from_code(code)))
+            }
+        }
+        CGEventType::ScrollWheel => {
+            let delta_y =
+                cg_event.get_integer_value_field(EventField::SCROLL_WHEEL_EVENT_POINT_DELTA_AXIS_1);
+            let delta_x =
+                cg_event.get_integer_value_field(EventField::SCROLL_WHEEL_EVENT_POINT_DELTA_AXIS_2);
+            Some(EventType::Wheel { delta_x, delta_y })
+        }
+        _ => None,
+    };
+    if let Some(event_type) = option_type {
+        let name = match event_type {
+            EventType::KeyPress(_) => {
+                let code =
+                    cg_event.get_integer_value_field(EventField::KEYBOARD_EVENT_KEYCODE) as u32;
+                let flags = cg_event.get_flags();
+                keyboard_state.create_string_for_key(code, flags)
+            }
+            _ => None,
+        };
+        return Some(Event {
+            event_type,
+            time: SystemTime::now(),
+            name,
+        });
+    }
+    None
+}
diff --git a/src/macos/display.rs b/src/macos/display.rs
new file mode 100644
index 0000000..00dc66c
--- /dev/null
+++ b/src/macos/display.rs
@@ -0,0 +1,7 @@
+use crate::rdev::DisplayError;
+use core_graphics::display::CGDisplay;
+
+pub fn display_size() -> Result<(u64, u64), DisplayError> {
+    let main = CGDisplay::main();
+    Ok((main.pixels_wide(), main.pixels_high()))
+}
diff --git a/src/macos/grab.rs b/src/macos/grab.rs
new file mode 100644
index 0000000..dd8de0f
--- /dev/null
+++ b/src/macos/grab.rs
@@ -0,0 +1,65 @@
+#![allow(improper_ctypes_definitions)]
+use crate::macos::common::*;
+use crate::rdev::{Event, GrabError};
+use cocoa::base::nil;
+use cocoa::foundation::NSAutoreleasePool;
+use core_graphics::event::{CGEventTapLocation, CGEventType};
+use std::os::raw::c_void;
+
+static mut GLOBAL_CALLBACK: Option<Box<dyn FnMut(Event) -> Option<Event>>> = None;
+
+#[link(name = "Cocoa", kind = "framework")]
+extern "C" {}
+
+unsafe extern "C" fn raw_callback(
+    _proxy: CGEventTapProxy,
+    _type: CGEventType,
+    cg_event: CGEventRef,
+    _user_info: *mut c_void,
+) -> CGEventRef {
+    // println!("Event ref {:?}", cg_event_ptr);
+    // let cg_event: CGEvent = transmute_copy::<*mut c_void, CGEvent>(&cg_event_ptr);
+    let opt = KEYBOARD_STATE.lock();
+    if let Ok(mut keyboard) = opt {
+        if let Some(event) = convert(_type, &cg_event, &mut keyboard) {
+            if let Some(callback) = &mut GLOBAL_CALLBACK {
+                if callback(event).is_none() {
+                    cg_event.set_type(CGEventType::Null);
+                }
+            }
+        }
+    }
+    cg_event
+}
+
+pub fn grab<T>(callback: T) -> Result<(), GrabError>
+where
+    T: FnMut(Event) -> Option<Event> + 'static,
+{
+    unsafe {
+        GLOBAL_CALLBACK = Some(Box::new(callback));
+        let _pool = NSAutoreleasePool::new(nil);
+        let tap = CGEventTapCreate(
+            CGEventTapLocation::HID, // HID, Session, AnnotatedSession,
+            kCGHeadInsertEventTap,
+            CGEventTapOption::Default,
+            kCGEventMaskForAllEvents,
+            raw_callback,
+            nil,
+        );
+        if tap.is_null() {
+            return Err(GrabError::EventTapError);
+        }
+        let _loop = CFMachPortCreateRunLoopSource(nil, tap, 0);
+        if _loop.is_null() {
+            return Err(GrabError::LoopSourceError);
+        }
+
+        let current_loop = CFRunLoopGetCurrent();
+        CFRunLoopAddSource(current_loop, _loop, kCFRunLoopCommonModes);
+
+        CGEventTapEnable(tap, true);
+        CFRunLoopRun();
+    }
+    Ok(())
+}
diff --git a/src/macos/keyboard.rs b/src/macos/keyboard.rs
new file mode 100644
index 0000000..131ef47
--- /dev/null
+++ b/src/macos/keyboard.rs
@@ -0,0 +1,188 @@
+#![allow(clippy::upper_case_acronyms)]
+use crate::macos::keycodes::code_from_key;
+use crate::rdev::{EventType, Key, KeyboardState};
+use core_foundation::base::{CFRelease, OSStatus};
+use core_foundation::string::UniChar;
+use core_foundation_sys::data::{CFDataGetBytePtr, CFDataRef};
+use core_graphics::event::CGEventFlags;
+use std::convert::TryInto;
+use std::ffi::c_void;
+use std::os::raw::c_uint;
+
+type TISInputSourceRef = *mut c_void;
+type ModifierState = u32;
+type UniCharCount = usize;
+
+type OptionBits = c_uint;
+#[allow(non_upper_case_globals)]
+static kUCKeyTranslateDeadKeysBit: OptionBits = 1 << 31;
+#[allow(non_upper_case_globals)]
+static kUCKeyActionDown: u16 = 0;
+#[allow(non_upper_case_globals)]
+static NSEventModifierFlagCapsLock: u64 = 1 << 16;
+#[allow(non_upper_case_globals)]
+static NSEventModifierFlagShift: u64 = 1 << 17;
+#[allow(non_upper_case_globals)]
+static NSEventModifierFlagControl: u64 = 1 << 18;
+#[allow(non_upper_case_globals)]
+static NSEventModifierFlagOption: u64 = 1 << 19;
+#[allow(non_upper_case_globals)]
+static NSEventModifierFlagCommand: u64 = 1 << 20;
+
+const BUF_LEN: usize = 4;
+
+#[cfg(target_os = "macos")]
+#[link(name = "Cocoa", kind = "framework")]
+#[link(name = "Carbon", kind = "framework")]
+extern "C" {
+    fn TISCopyCurrentKeyboardLayoutInputSource() -> TISInputSourceRef;
+    fn TISCopyCurrentKeyboardInputSource() -> TISInputSourceRef;
+    fn TISGetInputSourceProperty(source: TISInputSourceRef, property: *mut c_void) -> CFDataRef;
+    fn UCKeyTranslate(
+        layout: *const u8,
+        code: u16,
+        key_action: u16,
+        modifier_state: u32,
+        keyboard_type: u32,
+        key_translate_options: OptionBits,
+        dead_key_state: *mut u32,
+        max_length: UniCharCount,
+        actual_length: *mut UniCharCount,
+        unicode_string: *mut [UniChar; BUF_LEN],
+    ) -> OSStatus;
+    fn LMGetKbdType() -> u32;
+    static kTISPropertyUnicodeKeyLayoutData: *mut c_void;
+
+}
+
+pub struct Keyboard {
+    dead_state: u32,
+    shift: bool,
+    caps_lock: bool,
+}
+impl Keyboard {
+    pub fn new() -> Option<Keyboard> {
+        Some(Keyboard {
+            dead_state: 0,
+            shift: false,
+            caps_lock: false,
+        })
+    }
+
+    fn modifier_state(&self) -> ModifierState {
+        if self.caps_lock || self.shift {
+            2
+        } else {
+            0
+        }
+    }
+
+    pub(crate) unsafe fn create_string_for_key(
+        &mut self,
+        code: u32,
+        flags: CGEventFlags,
+    ) -> Option<String> {
+        let modifier_state = flags_to_state(flags.bits());
+        self.string_from_code(code, modifier_state)
+    }
+
+    pub(crate) unsafe fn string_from_code(
+        &mut self,
+        code: u32,
+        modifier_state: ModifierState,
+    ) -> Option<String> {
+        let mut keyboard = TISCopyCurrentKeyboardInputSource();
+        let mut layout = TISGetInputSourceProperty(keyboard, kTISPropertyUnicodeKeyLayoutData);
+
+        if layout.is_null() {
+            // TISGetInputSourceProperty returns NULL when using CJK input methods,
+            // using TISCopyCurrentKeyboardLayoutInputSource to fix it.
+            keyboard = TISCopyCurrentKeyboardLayoutInputSource();
+            layout = TISGetInputSourceProperty(keyboard, kTISPropertyUnicodeKeyLayoutData);
+            if layout.is_null() {
+                return None;
+            }
+        }
+        let layout_ptr = CFDataGetBytePtr(layout);
+
+        let mut buff = [0_u16; BUF_LEN];
+        let kb_type = LMGetKbdType();
+        let mut length = 0;
+        let _retval = UCKeyTranslate(
+            layout_ptr,
+            code.try_into().ok()?,
+            kUCKeyActionDown,
+            modifier_state,
+            kb_type,
+            kUCKeyTranslateDeadKeysBit,
+            &mut self.dead_state,                 // deadKeyState
+            BUF_LEN,                              // max string length
+            &mut length as *mut UniCharCount,     // actual string length
+            &mut buff as *mut [UniChar; BUF_LEN], // unicode string
+        );
+        CFRelease(keyboard);
+
+        String::from_utf16(&buff[..length]).ok()
+    }
+}
+
+impl KeyboardState for Keyboard {
+    fn add(&mut self, event_type: &EventType) -> Option<String> {
+        match event_type {
+            EventType::KeyPress(key) => match key {
+                Key::ShiftLeft | Key::ShiftRight => {
+                    self.shift = true;
+                    None
+                }
+                Key::CapsLock => {
+                    self.caps_lock = !self.caps_lock;
+                    None
+                }
+                key => {
+                    let code = code_from_key(*key)?;
+                    unsafe { self.string_from_code(code.into(), self.modifier_state()) }
+                }
+            },
+            EventType::KeyRelease(key) => match key {
+                Key::ShiftLeft | Key::ShiftRight => {
+                    self.shift = false;
+                    None
+                }
+                _ => None,
+            },
+            _ => None,
+        }
+    }
+
+    fn reset(&mut self) {
+        self.dead_state = 0;
+        self.shift = false;
+        self.caps_lock = false;
+    }
+}
+
+#[allow(clippy::identity_op)]
+pub unsafe fn flags_to_state(flags: u64) -> ModifierState {
+    let has_alt = flags & NSEventModifierFlagOption;
+    let has_caps_lock = flags & NSEventModifierFlagCapsLock;
+    let has_control = flags & NSEventModifierFlagControl;
+    let has_shift = flags & NSEventModifierFlagShift;
+    let has_meta = flags & NSEventModifierFlagCommand;
+    let mut modifier = 0;
+    if has_alt != 0 {
+        modifier += 1 << 3;
+    }
+    if has_caps_lock != 0 {
+        modifier += 1 << 1;
+    }
+    if has_control != 0 {
+        modifier += 1 << 4;
+    }
+    if has_shift != 0 {
+        modifier += 1 << 1;
+    }
+    if has_meta != 0 {
+        modifier += 1 << 0;
+    }
+    modifier
+}
diff --git a/src/macos/keycodes.rs b/src/macos/keycodes.rs
new file mode 100644
index 0000000..eeb6f98
--- /dev/null
+++ b/src/macos/keycodes.rs
@@ -0,0 +1,267 @@
+use crate::rdev::Key;
+use core_graphics::event::CGKeyCode;
+use std::convert::TryInto;
+
+/// Option
+const ALT: CGKeyCode = 58;
+/// Option_Right
+const ALT_GR: CGKeyCode = 61;
+const BACKSPACE: CGKeyCode = 51;
+const CAPS_LOCK: CGKeyCode = 57;
+const CONTROL_LEFT: CGKeyCode = 59;
+const CONTROL_RIGHT: CGKeyCode = 62;
+const DOWN_ARROW: CGKeyCode = 125;
+const ESCAPE: CGKeyCode = 53;
+const F1: CGKeyCode = 122;
+const F10: CGKeyCode = 109;
+const F11: CGKeyCode = 103;
+const F12: CGKeyCode = 111;
+const F2: CGKeyCode = 120;
+const F3: CGKeyCode = 99;
+const F4: CGKeyCode = 118;
+const F5: CGKeyCode = 96;
+const F6: CGKeyCode = 97;
+const F7: CGKeyCode = 98;
+const F8: CGKeyCode = 100;
+const F9: CGKeyCode = 101;
+const FUNCTION: CGKeyCode = 63;
+const LEFT_ARROW: CGKeyCode = 123;
+const META_LEFT: CGKeyCode = 55;
+const META_RIGHT: CGKeyCode = 54;
+const RETURN: CGKeyCode = 36;
+const RIGHT_ARROW: CGKeyCode = 124;
+const SHIFT_LEFT: CGKeyCode = 56;
+const SHIFT_RIGHT: CGKeyCode = 60;
+const SPACE: CGKeyCode = 49;
+const TAB: CGKeyCode = 48;
+const UP_ARROW: CGKeyCode = 126;
+const BACK_QUOTE: CGKeyCode = 50;
+const NUM1: CGKeyCode = 18;
+const NUM2: CGKeyCode = 19;
+const NUM3: CGKeyCode = 20;
+const NUM4: CGKeyCode = 21;
+const NUM5: CGKeyCode = 23;
+const NUM6: CGKeyCode = 22;
+const NUM7: CGKeyCode = 26;
+const NUM8: CGKeyCode = 28;
+const NUM9: CGKeyCode = 25;
+const NUM0: CGKeyCode = 29;
+const MINUS: CGKeyCode = 27;
+const EQUAL: CGKeyCode = 24;
+const KEY_Q: CGKeyCode = 12;
+const KEY_W: CGKeyCode = 13;
+const KEY_E: CGKeyCode = 14;
+const KEY_R: CGKeyCode = 15;
+const KEY_T: CGKeyCode = 17;
+const KEY_Y: CGKeyCode = 16;
+const KEY_U: CGKeyCode = 32;
+const KEY_I: CGKeyCode = 34;
+const KEY_O: CGKeyCode = 31;
+const KEY_P: CGKeyCode = 35;
+const LEFT_BRACKET: CGKeyCode = 33;
+const RIGHT_BRACKET: CGKeyCode = 30;
+const KEY_A: CGKeyCode = 0;
+const KEY_S: CGKeyCode = 1;
+const KEY_D: CGKeyCode = 2;
+const KEY_F: CGKeyCode = 3;
+const KEY_G: CGKeyCode = 5;
+const KEY_H: CGKeyCode = 4;
+const KEY_J: CGKeyCode = 38;
+const KEY_K: CGKeyCode = 40;
+const KEY_L: CGKeyCode = 37;
+const SEMI_COLON: CGKeyCode = 41;
+const QUOTE: CGKeyCode = 39;
+const BACK_SLASH: CGKeyCode = 42;
+const KEY_Z: CGKeyCode = 6;
+const KEY_X: CGKeyCode = 7;
+const KEY_C: CGKeyCode = 8;
+const KEY_V: CGKeyCode = 9;
+const KEY_B: CGKeyCode = 11;
+const KEY_N: CGKeyCode = 45;
+const KEY_M: CGKeyCode = 46;
+const COMMA: CGKeyCode = 43;
+const DOT: CGKeyCode = 47;
+const SLASH: CGKeyCode = 44;
+
+pub fn code_from_key(key: Key) -> Option<CGKeyCode> {
+    match key {
+        Key::Alt => Some(ALT),
+        Key::AltGr => Some(ALT_GR),
+        Key::Backspace => Some(BACKSPACE),
+        Key::CapsLock => Some(CAPS_LOCK),
+        Key::ControlLeft => Some(CONTROL_LEFT),
+        Key::ControlRight => Some(CONTROL_RIGHT),
+        Key::DownArrow => Some(DOWN_ARROW),
+        Key::Escape => Some(ESCAPE),
+        Key::F1 => Some(F1),
+        Key::F10 => Some(F10),
+        Key::F11 => Some(F11),
+        Key::F12 => Some(F12),
+        Key::F2 => Some(F2),
+        Key::F3 => Some(F3),
+        Key::F4 => Some(F4),
+        Key::F5 => Some(F5),
+        Key::F6 => Some(F6),
+        Key::F7 => Some(F7),
+        Key::F8 => Some(F8),
+        Key::F9 => Some(F9),
+        Key::LeftArrow => Some(LEFT_ARROW),
+        Key::MetaLeft => Some(META_LEFT),
+        Key::MetaRight => Some(META_RIGHT),
+        Key::Return => Some(RETURN),
+        Key::RightArrow => Some(RIGHT_ARROW),
+        Key::ShiftLeft => Some(SHIFT_LEFT),
+        Key::ShiftRight => Some(SHIFT_RIGHT),
+        Key::Space => Some(SPACE),
+        Key::Tab => Some(TAB),
+        Key::UpArrow => Some(UP_ARROW),
+        Key::BackQuote => Some(BACK_QUOTE),
+        Key::Num1 => Some(NUM1),
+        Key::Num2 => Some(NUM2),
+        Key::Num3 => Some(NUM3),
+        Key::Num4 => Some(NUM4),
+        Key::Num5 => Some(NUM5),
+        Key::Num6 => Some(NUM6),
+        Key::Num7 => Some(NUM7),
+        Key::Num8 => Some(NUM8),
+        Key::Num9 => Some(NUM9),
+        Key::Num0 => Some(NUM0),
+        Key::Minus => Some(MINUS),
+        Key::Equal => Some(EQUAL),
+        Key::KeyQ => Some(KEY_Q),
+        Key::KeyW => Some(KEY_W),
+        Key::KeyE => Some(KEY_E),
+        Key::KeyR => Some(KEY_R),
+        Key::KeyT => Some(KEY_T),
+        Key::KeyY => Some(KEY_Y),
+        Key::KeyU => Some(KEY_U),
+        Key::KeyI => Some(KEY_I),
+        Key::KeyO => Some(KEY_O),
+        Key::KeyP => Some(KEY_P),
+        Key::LeftBracket => Some(LEFT_BRACKET),
+        Key::RightBracket => Some(RIGHT_BRACKET),
+        Key::KeyA => Some(KEY_A),
+        Key::KeyS => Some(KEY_S),
+        Key::KeyD => Some(KEY_D),
+        Key::KeyF => Some(KEY_F),
+        Key::KeyG => Some(KEY_G),
+        Key::KeyH => Some(KEY_H),
+        Key::KeyJ => Some(KEY_J),
+        Key::KeyK => Some(KEY_K),
+        Key::KeyL => Some(KEY_L),
+        Key::SemiColon => Some(SEMI_COLON),
+        Key::Quote => Some(QUOTE),
+        Key::BackSlash => Some(BACK_SLASH),
+        Key::KeyZ => Some(KEY_Z),
+        Key::KeyX => Some(KEY_X),
+        Key::KeyC => Some(KEY_C),
+        Key::KeyV => Some(KEY_V),
+        Key::KeyB => Some(KEY_B),
+        Key::KeyN => Some(KEY_N),
+        Key::KeyM => Some(KEY_M),
+        Key::Comma => Some(COMMA),
+        Key::Dot => Some(DOT),
+        Key::Slash => Some(SLASH),
+        Key::Function => Some(FUNCTION),
+        Key::Unknown(code) => code.try_into().ok(),
+        _ => None,
+    }
+}
+
+pub fn key_from_code(code: CGKeyCode) -> Key {
+    match code {
+        ALT => Key::Alt,
+        ALT_GR => Key::AltGr,
+        BACKSPACE => Key::Backspace,
+        CAPS_LOCK => Key::CapsLock,
+        CONTROL_LEFT => Key::ControlLeft,
+        DOWN_ARROW => Key::DownArrow,
+        ESCAPE => Key::Escape,
+        F1 => Key::F1,
+        F10 => Key::F10,
+        F11 => Key::F11,
+        F12 => Key::F12,
+        F2 => Key::F2,
+        F3 => Key::F3,
+        F4 => Key::F4,
+        F5 => Key::F5,
+        F6 => Key::F6,
+        F7 => Key::F7,
+        F8 => Key::F8,
+        F9 => Key::F9,
+        LEFT_ARROW => Key::LeftArrow,
+        META_LEFT => Key::MetaLeft,
+        META_RIGHT => Key::MetaRight,
+        RETURN => Key::Return,
+        RIGHT_ARROW => Key::RightArrow,
+        SHIFT_LEFT => Key::ShiftLeft,
+        SHIFT_RIGHT => Key::ShiftRight,
+        SPACE => Key::Space,
+        TAB => Key::Tab,
+        UP_ARROW => Key::UpArrow,
+        BACK_QUOTE => Key::BackQuote,
+        NUM1 => Key::Num1,
+        NUM2 => Key::Num2,
+        NUM3 => Key::Num3,
+        NUM4 => Key::Num4,
+        NUM5 => Key::Num5,
+        NUM6 => Key::Num6,
+        NUM7 => Key::Num7,
+        NUM8 => Key::Num8,
+        NUM9 => Key::Num9,
+        NUM0 => Key::Num0,
+        MINUS => Key::Minus,
+        EQUAL => Key::Equal,
+        KEY_Q => Key::KeyQ,
+        KEY_W => Key::KeyW,
+        KEY_E => Key::KeyE,
+        KEY_R => Key::KeyR,
+        KEY_T => Key::KeyT,
+        KEY_Y => Key::KeyY,
+        KEY_U => Key::KeyU,
+        KEY_I => Key::KeyI,
+        KEY_O => Key::KeyO,
+        KEY_P => Key::KeyP,
+        LEFT_BRACKET => Key::LeftBracket,
+        RIGHT_BRACKET => Key::RightBracket,
+        KEY_A => Key::KeyA,
+        KEY_S => Key::KeyS,
+        KEY_D => Key::KeyD,
+        KEY_F => Key::KeyF,
+        KEY_G => Key::KeyG,
+        KEY_H => Key::KeyH,
+        KEY_J => Key::KeyJ,
+        KEY_K => Key::KeyK,
+        KEY_L => Key::KeyL,
+        SEMI_COLON => Key::SemiColon,
+        QUOTE => Key::Quote,
+        BACK_SLASH => Key::BackSlash,
+        KEY_Z => Key::KeyZ,
+        KEY_X => Key::KeyX,
+        KEY_C => Key::KeyC,
+        KEY_V => Key::KeyV,
+        KEY_B => Key::KeyB,
+        KEY_N => Key::KeyN,
+        KEY_M => Key::KeyM,
+        COMMA => Key::Comma,
+        DOT => Key::Dot,
+        SLASH => Key::Slash,
+        FUNCTION => Key::Function,
+        code => Key::Unknown(code.into()),
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::{code_from_key, key_from_code};
+    #[test]
+    fn test_reversible() {
+        for code in 0..=65535 {
+            let key = key_from_code(code);
+            match code_from_key(key) {
+                Some(code2) => assert_eq!(code, code2),
+                None => panic!("Could not convert back code: {:?}", code),
+            }
+        }
+    }
+}
diff --git a/src/macos/listen.rs b/src/macos/listen.rs
new file mode 100644
index 0000000..611ea8c
--- /dev/null
+++ b/src/macos/listen.rs
@@ -0,0 +1,65 @@
+#![allow(improper_ctypes_definitions)]
+use crate::macos::common::*;
+use crate::rdev::{Event, ListenError};
+use cocoa::base::nil;
+use cocoa::foundation::NSAutoreleasePool;
+use core_graphics::event::{CGEventTapLocation, CGEventType};
+use std::os::raw::c_void;
+
+static mut GLOBAL_CALLBACK: Option<Box<dyn FnMut(Event)>> = None;
+
+#[link(name = "Cocoa", kind = "framework")]
+extern "C" {}
+
+unsafe extern "C" fn raw_callback(
+    _proxy: CGEventTapProxy,
+    _type: CGEventType,
+    cg_event: CGEventRef,
+    _user_info: *mut c_void,
+) -> CGEventRef {
+    // println!("Event ref {:?}", cg_event_ptr);
+    // let cg_event: CGEvent = transmute_copy::<*mut c_void, CGEvent>(&cg_event_ptr);
+    let opt = KEYBOARD_STATE.lock();
+    if let Ok(mut keyboard) = opt {
+        if let Some(event) = convert(_type, &cg_event, &mut keyboard) {
+            if let Some(callback) = &mut GLOBAL_CALLBACK {
+                callback(event);
+            }
+        }
+    }
+    // println!("Event ref END {:?}", cg_event_ptr);
+    // cg_event_ptr
+    cg_event
+}
+
+pub fn listen<T>(callback: T) -> Result<(), ListenError>
+where
+    T: FnMut(Event) + 'static,
+{
+    unsafe {
+        GLOBAL_CALLBACK = Some(Box::new(callback));
+        let _pool = NSAutoreleasePool::new(nil);
+        let tap = CGEventTapCreate(
+            CGEventTapLocation::HID, // HID, Session, AnnotatedSession,
+            kCGHeadInsertEventTap,
+            CGEventTapOption::ListenOnly,
+            kCGEventMaskForAllEvents,
+            raw_callback,
+            nil,
+        );
+        if tap.is_null() {
+            return Err(ListenError::EventTapError);
+        }
+        let _loop = CFMachPortCreateRunLoopSource(nil, tap, 0);
+        if _loop.is_null() {
+            return Err(ListenError::LoopSourceError);
+        }
+
+        let current_loop = CFRunLoopGetCurrent();
+        CFRunLoopAddSource(current_loop, _loop, kCFRunLoopCommonModes);
+
+        CGEventTapEnable(tap, true);
+        CFRunLoopRun();
+    }
+    Ok(())
+}
diff --git a/src/macos/mod.rs b/src/macos/mod.rs
new file mode 100644
index 0000000..ae5e64a
--- /dev/null
+++ b/src/macos/mod.rs
@@ -0,0 +1,16 @@
+mod common;
+mod display;
+#[cfg(feature = "unstable_grab")]
+mod grab;
+mod keyboard;
+mod keycodes;
+mod listen;
+mod simulate;
+
+pub use crate::macos::keycodes::{key_from_code, code_from_key};
+pub use crate::macos::display::display_size;
+#[cfg(feature = "unstable_grab")]
+pub use crate::macos::grab::grab;
+pub use crate::macos::keyboard::Keyboard;
+pub use crate::macos::listen::listen;
+pub use crate::macos::simulate::simulate;
diff --git a/src/macos/simulate.rs b/src/macos/simulate.rs
new file mode 100644
index 0000000..6242e19
--- /dev/null
+++ b/src/macos/simulate.rs
@@ -0,0 +1,97 @@
+use crate::rdev::{Button, EventType, SimulateError};
+use core_graphics::event::{
+    CGEvent, CGEventTapLocation, CGEventType, CGMouseButton, ScrollEventUnit,
+};
+use core_graphics::event_source::{CGEventSource, CGEventSourceStateID};
+use core_graphics::geometry::CGPoint;
+use std::convert::TryInto;
+
+use crate::macos::keycodes::code_from_key;
+
+unsafe fn convert_native_with_source(
+    event_type: &EventType,
+    source: CGEventSource,
+) -> Option<CGEvent> {
+    match event_type {
+        EventType::KeyPress(key) => {
+            let code = code_from_key(*key)?;
+            CGEvent::new_keyboard_event(source, code, true).ok()
+        }
+        EventType::KeyRelease(key) => {
+            let code = code_from_key(*key)?;
+            CGEvent::new_keyboard_event(source, code, false).ok()
+        }
+        EventType::ButtonPress(button) => {
+            let point = get_current_mouse_location()?;
+            let event = match button {
+                Button::Left => CGEventType::LeftMouseDown,
+                Button::Right => CGEventType::RightMouseDown,
+                _ => return None,
+            };
+            CGEvent::new_mouse_event(
+                source,
+                event,
+                point,
+                CGMouseButton::Left, // ignored because we don't use OtherMouse EventType
+            )
+            .ok()
+        }
+        EventType::ButtonRelease(button) => {
+            let point = get_current_mouse_location()?;
+            let event = match button {
+                Button::Left => CGEventType::LeftMouseUp,
+                Button::Right => CGEventType::RightMouseUp,
+                _ => return None,
+            };
+            CGEvent::new_mouse_event(
+                source,
+                event,
+                point,
+                CGMouseButton::Left, // ignored because we don't use OtherMouse EventType
+            )
+            .ok()
+        }
+        EventType::MouseMove { x, y } => {
+            let point = CGPoint { x: (*x), y: (*y) };
+            CGEvent::new_mouse_event(source, CGEventType::MouseMoved, point, CGMouseButton::Left)
+                .ok()
+        }
+        EventType::Wheel { delta_x, delta_y } => {
+            let wheel_count = 2;
+            CGEvent::new_scroll_event(
+                source,
+                ScrollEventUnit::PIXEL,
+                wheel_count,
+                (*delta_y).try_into().ok()?,
+                (*delta_x).try_into().ok()?,
+                0,
+            )
+            .ok()
+        }
+    }
+}
+
+unsafe fn convert_native(event_type: &EventType) -> Option<CGEvent> {
+    let source = CGEventSource::new(CGEventSourceStateID::HIDSystemState).ok()?;
+    convert_native_with_source(event_type, source)
+}
+
+unsafe fn get_current_mouse_location() -> Option<CGPoint> {
+    let source = CGEventSource::new(CGEventSourceStateID::HIDSystemState).ok()?;
+    let event = CGEvent::new(source).ok()?;
+    Some(event.location())
+}
+
+#[link(name = "Cocoa", kind = "framework")]
+extern "C" {}
+
+pub fn simulate(event_type: &EventType) -> Result<(), SimulateError> {
+    unsafe {
+        if let Some(cg_event) = convert_native(event_type) {
+            cg_event.post(CGEventTapLocation::HID);
+            Ok(())
+        } else {
+            Err(SimulateError)
+        }
+    }
+}
diff --git a/src/rdev.rs b/src/rdev.rs
new file mode 100644
index 0000000..277be3b
--- /dev/null
+++ b/src/rdev.rs
@@ -0,0 +1,291 @@
+#[cfg(feature = "serialize")]
+use serde::{Deserialize, Serialize};
+use std::time::SystemTime;
+use std::{fmt, fmt::Display};
+
+// /// Callback type to send to listen function.
+// pub type Callback = dyn FnMut(Event) -> ();
+
+/// Callback type to send to grab function.
+pub type GrabCallback = fn(event: Event) -> Option<Event>;
+
+/// Errors that occur when trying to capture OS events.
+/// Be careful on Mac, not setting accessibility does not cause an error
+/// it justs ignores events.
+#[derive(Debug)]
+#[non_exhaustive]
+pub enum ListenError {
+    /// MacOS
+    EventTapError,
+    /// MacOS
+    LoopSourceError,
+    /// Linux
+    MissingDisplayError,
+    /// Linux
+    KeyboardError,
+    /// Linux
+    RecordContextEnablingError,
+    /// Linux
+    RecordContextError,
+    /// Linux
+    XRecordExtensionError,
+    /// Windows
+    KeyHookError(u32),
+    /// Windows
+    MouseHookError(u32),
+}
+
+/// Errors that occur when trying to grab OS events.
+/// Be careful on Mac, not setting accessibility does not cause an error
+/// it justs ignores events.
+#[derive(Debug)]
+#[non_exhaustive]
+pub enum GrabError {
+    /// MacOS
+    EventTapError,
+    /// MacOS
+    LoopSourceError,
+    /// Linux
+    MissingDisplayError,
+    /// Linux
+    KeyboardError,
+    /// Windows
+    KeyHookError(u32),
+    /// Windows
+    MouseHookError(u32),
+    /// All
+    SimulateError,
+    IoError(std::io::Error),
+}
+/// Errors that occur when trying to get display size.
+#[non_exhaustive]
+#[derive(Debug)]
+pub enum DisplayError {
+    NoDisplay,
+    ConversionError,
+}
+
+impl From<SimulateError> for GrabError {
+    fn from(_: SimulateError) -> GrabError {
+        GrabError::SimulateError
+    }
+}
+
+impl From<std::io::Error> for GrabError {
+    fn from(err: std::io::Error) -> GrabError {
+        GrabError::IoError(err)
+    }
+}
+
+/// Marking an error when we tried to simulate and event
+#[derive(Debug)]
+pub struct SimulateError;
+
+impl Display for SimulateError {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        write!(f, "Could not simulate event")
+    }
+}
+
+impl std::error::Error for SimulateError {}
+
+/// Key names based on physical location on the device
+/// Merge Option(MacOS) and Alt(Windows, Linux) into Alt
+/// Merge Windows (Windows), Meta(Linux), Command(MacOS) into Meta
+/// Characters based on Qwerty layout, don't use this for characters as it WILL
+/// depend on the layout. Use Event.name instead. Key modifiers gives those keys
+/// a different value too.
+/// Careful, on Windows KpReturn does not exist, it' s strictly equivalent to Return, also Keypad keys
+/// get modified if NumLock is Off and ARE pagedown and so on.
+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub enum Key {
+    /// Alt key on Linux and Windows (option key on macOS)
+    Alt,
+    AltGr,
+    Backspace,
+    CapsLock,
+    ControlLeft,
+    ControlRight,
+    Delete,
+    DownArrow,
+    End,
+    Escape,
+    F1,
+    F10,
+    F11,
+    F12,
+    F2,
+    F3,
+    F4,
+    F5,
+    F6,
+    F7,
+    F8,
+    F9,
+    Home,
+    LeftArrow,
+    /// also known as "windows", "super", and "command"
+    MetaLeft,
+    /// also known as "windows", "super", and "command"
+    MetaRight,
+    PageDown,
+    PageUp,
+    Return,
+    RightArrow,
+    ShiftLeft,
+    ShiftRight,
+    Space,
+    Tab,
+    UpArrow,
+    PrintScreen,
+    ScrollLock,
+    Pause,
+    NumLock,
+    BackQuote,
+    Num1,
+    Num2,
+    Num3,
+    Num4,
+    Num5,
+    Num6,
+    Num7,
+    Num8,
+    Num9,
+    Num0,
+    Minus,
+    Equal,
+    KeyQ,
+    KeyW,
+    KeyE,
+    KeyR,
+    KeyT,
+    KeyY,
+    KeyU,
+    KeyI,
+    KeyO,
+    KeyP,
+    LeftBracket,
+    RightBracket,
+    KeyA,
+    KeyS,
+    KeyD,
+    KeyF,
+    KeyG,
+    KeyH,
+    KeyJ,
+    KeyK,
+    KeyL,
+    SemiColon,
+    Quote,
+    BackSlash,
+    IntlBackslash,
+    KeyZ,
+    KeyX,
+    KeyC,
+    KeyV,
+    KeyB,
+    KeyN,
+    KeyM,
+    Comma,
+    Dot,
+    Slash,
+    Insert,
+    KpReturn,
+    KpMinus,
+    KpPlus,
+    KpMultiply,
+    KpDivide,
+    Kp0,
+    Kp1,
+    Kp2,
+    Kp3,
+    Kp4,
+    Kp5,
+    Kp6,
+    Kp7,
+    Kp8,
+    Kp9,
+    KpDelete,
+    Function,
+    Unknown(u32),
+}
+
+/// Standard mouse buttons
+/// Some mice have more than 3 buttons. These are not defined, and different
+/// OSs will give different `Button::Unknown` values.
+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub enum Button {
+    Left,
+    Right,
+    Middle,
+    Unknown(u8),
+}
+
+/// In order to manage different OSs, the current EventType choices are a mix and
+/// match to account for all possible events.
+#[derive(Debug, Copy, Clone, PartialEq)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub enum EventType {
+    /// The keys correspond to a standard qwerty layout, they don't correspond
+    /// To the actual letter a user would use, that requires some layout logic to be added.
+    KeyPress(Key),
+    KeyRelease(Key),
+    /// Mouse Button
+    ButtonPress(Button),
+    ButtonRelease(Button),
+    /// Values in pixels. `EventType::MouseMove{x: 0, y: 0}` corresponds to the
+    /// top left corner, with x increasing downward and y increasing rightward
+    MouseMove {
+        x: f64,
+        y: f64,
+    },
+    /// `delta_y` represents vertical scroll and `delta_x` represents horizontal scroll.
+    /// Positive values correspond to scrolling up or right and negative values
+    /// correspond to scrolling down or left
+    Wheel {
+        delta_x: i64,
+        delta_y: i64,
+    },
+}
+
+/// When events arrive from the OS they get some additional information added from
+/// EventType, which is the time when this event was received, and the name Option
+/// which contains what characters should be emmitted from that event. This relies
+/// on the OS layout and keyboard state machinery.
+/// Caveat: Dead keys don't function on Linux(X11) yet. You will receive None for
+/// a dead key, and the raw letter instead of accentuated letter.
+#[derive(Debug, Clone, PartialEq)]
+#[cfg_attr(feature = "serialize", derive(Serialize, Deserialize))]
+pub struct Event {
+    pub time: SystemTime,
+    pub name: Option<String>,
+    pub event_type: EventType,
+}
+
+/// We can define a dummy Keyboard, that we will use to detect
+/// what kind of EventType trigger some String. We get the currently used
+/// layout for now !
+/// Caveat : This is layout dependent. If your app needs to support
+/// layout switching don't use this !
+/// Caveat: On Linux, the dead keys mechanism is not implemented.
+/// Caveat: Only shift and dead keys are implemented, Alt+unicode code on windows
+/// won't work.
+///
+/// ```no_run
+/// use rdev::{Keyboard, EventType, Key, KeyboardState};
+///
+/// let mut keyboard = Keyboard::new().unwrap();
+/// let string = keyboard.add(&EventType::KeyPress(Key::KeyS));
+/// // string == Some("s")
+/// ```
+pub trait KeyboardState {
+    /// Changes the keyboard state as if this event happened. we don't
+    /// really hit the OS here, which might come handy to test what should happen
+    /// if we were to hit said key.
+    fn add(&mut self, event_type: &EventType) -> Option<String>;
+
+    /// Resets the keyboard state as if we never touched it (no shift, caps_lock and so on)
+    fn reset(&mut self);
+}
diff --git a/src/windows/common.rs b/src/windows/common.rs
new file mode 100644
index 0000000..a7579c5
--- /dev/null
+++ b/src/windows/common.rs
@@ -0,0 +1,127 @@
+use crate::rdev::{Button, EventType};
+use crate::windows::keyboard::Keyboard;
+use crate::windows::keycodes::key_from_code;
+use lazy_static::lazy_static;
+use std::convert::TryInto;
+use std::os::raw::{c_int, c_short};
+use std::ptr::null_mut;
+use std::sync::Mutex;
+use winapi::shared::minwindef::{DWORD, HIWORD, LPARAM, LRESULT, WORD, WPARAM};
+use winapi::shared::ntdef::LONG;
+use winapi::shared::windef::HHOOK;
+use winapi::um::errhandlingapi::GetLastError;
+use winapi::um::winuser::{
+    SetWindowsHookExA, KBDLLHOOKSTRUCT, MSLLHOOKSTRUCT, WHEEL_DELTA, WH_KEYBOARD_LL, WH_MOUSE_LL,
+    WM_KEYDOWN, WM_KEYUP, WM_LBUTTONDOWN, WM_LBUTTONUP, WM_MBUTTONDOWN, WM_MBUTTONUP,
+    WM_MOUSEHWHEEL, WM_MOUSEMOVE, WM_MOUSEWHEEL, WM_RBUTTONDOWN, WM_RBUTTONUP, WM_SYSKEYDOWN,
+    WM_SYSKEYUP, WM_XBUTTONDOWN, WM_XBUTTONUP,
+};
+pub const TRUE: i32 = 1;
+pub const FALSE: i32 = 0;
+
+pub static mut HOOK: HHOOK = null_mut();
+lazy_static! {
+    pub(crate) static ref KEYBOARD: Mutex<Keyboard> = Mutex::new(Keyboard::new().unwrap());
+}
+
+pub unsafe fn get_code(lpdata: LPARAM) -> DWORD {
+    let kb = *(lpdata as *const KBDLLHOOKSTRUCT);
+    kb.vkCode
+}
+pub unsafe fn get_scan_code(lpdata: LPARAM) -> DWORD {
+    let kb = *(lpdata as *const KBDLLHOOKSTRUCT);
+    kb.scanCode
+}
+pub unsafe fn get_point(lpdata: LPARAM) -> (LONG, LONG) {
+    let mouse = *(lpdata as *const MSLLHOOKSTRUCT);
+    (mouse.pt.x, mouse.pt.y)
+}
+// https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms644986(v=vs.85)
+/// confusingly, this function returns a WORD (unsigned), but may be
+/// interpreted as either signed or unsigned depending on context
+pub unsafe fn get_delta(lpdata: LPARAM) -> WORD {
+    let mouse = *(lpdata as *const MSLLHOOKSTRUCT);
+    HIWORD(mouse.mouseData)
+}
+pub unsafe fn get_button_code(lpdata: LPARAM) -> WORD {
+    let mouse = *(lpdata as *const MSLLHOOKSTRUCT);
+    HIWORD(mouse.mouseData)
+}
+
+pub unsafe fn convert(param: WPARAM, lpdata: LPARAM) -> Option<EventType> {
+    match param.try_into() {
+        Ok(WM_KEYDOWN) | Ok(WM_SYSKEYDOWN) => {
+            let code = get_code(lpdata);
+            let key = key_from_code(code as u16);
+            Some(EventType::KeyPress(key))
+        }
+        Ok(WM_KEYUP) | Ok(WM_SYSKEYUP) => {
+            let code = get_code(lpdata);
+            let key = key_from_code(code as u16);
+            Some(EventType::KeyRelease(key))
+        }
+        Ok(WM_LBUTTONDOWN) => Some(EventType::ButtonPress(Button::Left)),
+        Ok(WM_LBUTTONUP) => Some(EventType::ButtonRelease(Button::Left)),
+        Ok(WM_MBUTTONDOWN) => Some(EventType::ButtonPress(Button::Middle)),
+        Ok(WM_MBUTTONUP) => Some(EventType::ButtonRelease(Button::Middle)),
+        Ok(WM_RBUTTONDOWN) => Some(EventType::ButtonPress(Button::Right)),
+        Ok(WM_RBUTTONUP) => Some(EventType::ButtonRelease(Button::Right)),
+        Ok(WM_XBUTTONDOWN) => {
+            let code = get_button_code(lpdata) as u8;
+            Some(EventType::ButtonPress(Button::Unknown(code)))
+        }
+        Ok(WM_XBUTTONUP) => {
+            let code = get_button_code(lpdata) as u8;
+            Some(EventType::ButtonRelease(Button::Unknown(code)))
+        }
+        Ok(WM_MOUSEMOVE) => {
+            let (x, y) = get_point(lpdata);
+            Some(EventType::MouseMove {
+                x: x as f64,
+                y: y as f64,
+            })
+        }
+        Ok(WM_MOUSEWHEEL) => {
+            let delta = get_delta(lpdata) as c_short;
+            Some(EventType::Wheel {
+                delta_x: 0,
+                delta_y: (delta / WHEEL_DELTA) as i64,
+            })
+        }
+        Ok(WM_MOUSEHWHEEL) => {
+            let delta = get_delta(lpdata) as c_short;
+            Some(EventType::Wheel {
+                delta_x: (delta / WHEEL_DELTA) as i64,
+                delta_y: 0,
+            })
+        }
+        _ => None,
+    }
+}
+
+type RawCallback = unsafe extern "system" fn(code: c_int, param: WPARAM, lpdata: LPARAM) -> LRESULT;
+pub enum HookError {
+    Mouse(DWORD),
+    Key(DWORD),
+}
+
+pub unsafe fn set_key_hook(callback: RawCallback) -> Result<(), HookError> {
+    let hook = SetWindowsHookExA(WH_KEYBOARD_LL, Some(callback), null_mut(), 0);
+
+    if hook.is_null() {
+        let error = GetLastError();
+        return Err(HookError::Key(error));
+    }
+    HOOK = hook;
+    Ok(())
+}
+
+pub unsafe fn set_mouse_hook(callback: RawCallback) -> Result<(), HookError> {
+    let hook = SetWindowsHookExA(WH_MOUSE_LL, Some(callback), null_mut(), 0);
+    if hook.is_null() {
+        let error = GetLastError();
+        return Err(HookError::Mouse(error));
+    }
+    HOOK = hook;
+    Ok(())
+}
diff --git a/src/windows/display.rs b/src/windows/display.rs
new file mode 100644
index 0000000..c7db82f
--- /dev/null
+++ b/src/windows/display.rs
@@ -0,0 +1,17 @@
+use crate::rdev::DisplayError;
+use std::convert::TryInto;
+use winapi::um::winuser::{GetSystemMetrics, SM_CXSCREEN, SM_CYSCREEN};
+
+pub fn display_size() -> Result<(u64, u64), DisplayError> {
+    let w = unsafe {
+        GetSystemMetrics(SM_CXSCREEN)
+            .try_into()
+            .map_err(|_| DisplayError::ConversionError)?
+    };
+    let h = unsafe {
+        GetSystemMetrics(SM_CYSCREEN)
+            .try_into()
+            .map_err(|_| DisplayError::ConversionError)?
+    };
+    Ok((w, h))
+}
diff --git a/src/windows/grab.rs b/src/windows/grab.rs
new file mode 100644
index 0000000..cd1930f
--- /dev/null
+++ b/src/windows/grab.rs
@@ -0,0 +1,59 @@
+use crate::rdev::{Event, EventType, GrabError};
+use crate::windows::common::{convert, set_key_hook, set_mouse_hook, HookError, HOOK, KEYBOARD};
+use std::ptr::null_mut;
+use std::time::SystemTime;
+use winapi::um::winuser::{CallNextHookEx, GetMessageA, HC_ACTION};
+
+static mut GLOBAL_CALLBACK: Option<Box<dyn FnMut(Event) -> Option<Event>>> = None;
+
+unsafe extern "system" fn raw_callback(code: i32, param: usize, lpdata: isize) -> isize {
+    if code == HC_ACTION {
+        let opt = convert(param, lpdata);
+        if let Some(event_type) = opt {
+            let name = match &event_type {
+                EventType::KeyPress(_key) => match (*KEYBOARD).lock() {
+                    Ok(mut keyboard) => keyboard.get_name(lpdata),
+                    Err(_) => None,
+                },
+                _ => None,
+            };
+            let event = Event {
+                event_type,
+                time: SystemTime::now(),
+                name,
+            };
+            if let Some(callback) = &mut GLOBAL_CALLBACK {
+                if callback(event).is_none() {
+                    // https://stackoverflow.com/questions/42756284/blocking-windows-mouse-click-using-setwindowshookex
+                    // https://android.developreference.com/article/14560004/Blocking+windows+mouse+click+using+SetWindowsHookEx()
+                    // https://cboard.cprogramming.com/windows-programming/99678-setwindowshookex-wm_keyboard_ll.html
+                    // let _result = CallNextHookEx(HOOK, code, param, lpdata);
+                    return 1;
+                }
+            }
+        }
+    }
+    CallNextHookEx(HOOK, code, param, lpdata)
+}
+impl From<HookError> for GrabError {
+    fn from(error: HookError) -> Self {
+        match error {
+            HookError::Mouse(code) => GrabError::MouseHookError(code),
+            HookError::Key(code) => GrabError::KeyHookError(code),
+        }
+    }
+}
+
+pub fn grab<T>(callback: T) -> Result<(), GrabError>
+where
+    T: FnMut(Event) -> Option<Event> + 'static,
+{
+    unsafe {
+        GLOBAL_CALLBACK = Some(Box::new(callback));
+        set_key_hook(raw_callback)?;
+        set_mouse_hook(raw_callback)?;
+
+        GetMessageA(null_mut(), null_mut(), 0, 0);
+    }
+    Ok(())
+}
diff --git a/src/windows/keyboard.rs b/src/windows/keyboard.rs
new file mode 100644
index 0000000..7eeb275
--- /dev/null
+++ b/src/windows/keyboard.rs
@@ -0,0 +1,175 @@
+use crate::rdev::{EventType, Key, KeyboardState};
+use crate::windows::common::{get_code, get_scan_code, FALSE, TRUE};
+use crate::windows::keycodes::code_from_key;
+use std::ptr::null_mut;
+use winapi::shared::minwindef::{BYTE, HKL, LPARAM, UINT};
+use winapi::um::processthreadsapi::GetCurrentThreadId;
+use winapi::um::winuser;
+use winapi::um::winuser::{
+    GetForegroundWindow, GetKeyState, GetKeyboardLayout, GetKeyboardState,
+    GetWindowThreadProcessId, ToUnicodeEx, VK_CAPITAL, VK_LSHIFT, VK_RSHIFT, VK_SHIFT,
+};
+
+const VK_SHIFT_: usize = VK_SHIFT as usize;
+const VK_CAPITAL_: usize = VK_CAPITAL as usize;
+const VK_LSHIFT_: usize = VK_LSHIFT as usize;
+const VK_RSHIFT_: usize = VK_RSHIFT as usize;
+const HIGHBIT: u8 = 0x80;
+
+pub struct Keyboard {
+    last_code: UINT,
+    last_scan_code: UINT,
+    last_state: [BYTE; 256],
+    last_is_dead: bool,
+}
+
+impl Keyboard {
+    pub fn new() -> Option<Keyboard> {
+        Some(Keyboard {
+            last_code: 0,
+            last_scan_code: 0,
+            last_state: [0; 256],
+            last_is_dead: false,
+        })
+    }
+
+    pub(crate) unsafe fn get_name(&mut self, lpdata: LPARAM) -> Option<String> {
+        // https://gist.github.com/akimsko/2011327
+        // https://www.experts-exchange.com/questions/23453780/LowLevel-Keystroke-Hook-removes-Accents-on-French-Keyboard.html
+        let code = get_code(lpdata);
+        let scan_code = get_scan_code(lpdata);
+
+        self.set_global_state()?;
+        self.get_code_name(code, scan_code)
+    }
+
+    pub(crate) unsafe fn set_global_state(&mut self) -> Option<()> {
+        let mut state = [0_u8; 256];
+        let state_ptr = state.as_mut_ptr();
+
+        let _shift = GetKeyState(VK_SHIFT);
+        let current_window_thread_id = GetWindowThreadProcessId(GetForegroundWindow(), null_mut());
+        let thread_id = GetCurrentThreadId();
+        // Attach to active thread so we can get that keyboard state
+        let status = if winuser::AttachThreadInput(thread_id, current_window_thread_id, TRUE) == 1 {
+            // Current state of the modifiers in keyboard
+            let status = GetKeyboardState(state_ptr);
+
+            // Detach
+            winuser::AttachThreadInput(thread_id, current_window_thread_id, FALSE);
+            status
+        } else {
+            // Could not attach, perhaps it is this process?
+            GetKeyboardState(state_ptr)
+        };
+
+        if status != 1 {
+            return None;
+        }
+        self.last_state = state;
+        Some(())
+    }
+
+    pub(crate) unsafe fn get_code_name(&mut self, code: UINT, scan_code: UINT) -> Option<String> {
+        let current_window_thread_id = GetWindowThreadProcessId(GetForegroundWindow(), null_mut());
+        let state_ptr = self.last_state.as_mut_ptr();
+        const BUF_LEN: i32 = 32;
+        let mut buff = [0_u16; BUF_LEN as usize];
+        let buff_ptr = buff.as_mut_ptr();
+        let layout = GetKeyboardLayout(current_window_thread_id);
+        let len = ToUnicodeEx(code, scan_code, state_ptr, buff_ptr, 8 - 1, 0, layout);
+
+        let mut is_dead = false;
+        let result = match len {
+            0 => None,
+            -1 => {
+                is_dead = true;
+                self.clear_keyboard_buffer(code, scan_code, layout);
+                None
+            }
+            len if len > 0 => String::from_utf16(&buff[..len as usize]).ok(),
+            _ => None,
+        };
+
+        if self.last_code != 0 && self.last_is_dead {
+            buff = [0; 32];
+            let buff_ptr = buff.as_mut_ptr();
+            let last_state_ptr = self.last_state.as_mut_ptr();
+            ToUnicodeEx(
+                self.last_code,
+                self.last_scan_code,
+                last_state_ptr,
+                buff_ptr,
+                BUF_LEN,
+                0,
+                layout,
+            );
+            self.last_code = 0;
+        } else {
+            self.last_code = code;
+            self.last_scan_code = scan_code;
+            self.last_is_dead = is_dead;
+        }
+        result
+    }
+
+    unsafe fn clear_keyboard_buffer(&self, code: UINT, scan_code: UINT, layout: HKL) {
+        const BUF_LEN: i32 = 32;
+        let mut buff = [0_u16; BUF_LEN as usize];
+        let buff_ptr = buff.as_mut_ptr();
+        let mut state = [0_u8; 256];
+        let state_ptr = state.as_mut_ptr();
+
+        let mut len = -1;
+        while len < 0 {
+            len = ToUnicodeEx(code, scan_code, state_ptr, buff_ptr, BUF_LEN, 0, layout);
+        }
+    }
+}
+
+impl KeyboardState for Keyboard {
+    fn add(&mut self, event_type: &EventType) -> Option<String> {
+        match event_type {
+            EventType::KeyPress(key) => match key {
+                Key::ShiftLeft => {
+                    self.last_state[VK_SHIFT_] |= HIGHBIT;
+                    self.last_state[VK_LSHIFT_] |= HIGHBIT;
+                    None
+                }
+                Key::ShiftRight => {
+                    self.last_state[VK_SHIFT_] |= HIGHBIT;
+                    self.last_state[VK_RSHIFT_] |= HIGHBIT;
+                    None
+                }
+                Key::CapsLock => {
+                    self.last_state[VK_CAPITAL_] ^= HIGHBIT;
+                    None
+                }
+                key => {
+                    let code = code_from_key(*key)?;
+                    unsafe { self.get_code_name(code.into(), 0) }
+                }
+            },
+            EventType::KeyRelease(key) => match key {
+                Key::ShiftLeft => {
+                    self.last_state[VK_SHIFT_] &= !HIGHBIT;
+                    self.last_state[VK_LSHIFT_] &= !HIGHBIT;
+                    None
+                }
+                Key::ShiftRight => {
+                    self.last_state[VK_SHIFT_] &= !HIGHBIT;
+                    self.last_state[VK_RSHIFT_] &= HIGHBIT;
+                    None
+                }
+                _ => None,
+            },
+
+            _ => None,
+        }
+    }
+
+    fn reset(&mut self) {
+        self.last_state[16] = 0;
+        self.last_state[20] = 0;
+    }
+}
diff --git a/src/windows/keycodes.rs b/src/windows/keycodes.rs
new file mode 100644
index 0000000..c3707f7
--- /dev/null
+++ b/src/windows/keycodes.rs
@@ -0,0 +1,152 @@
+use crate::rdev::Key;
+use std::convert::TryInto;
+use winapi::shared::minwindef::WORD;
+
+macro_rules! decl_keycodes {
+    ($($key:ident, $code:literal),*) => {
+        //TODO: make const when rust lang issue #49146 is fixed
+        pub fn code_from_key(key: Key) -> Option<WORD> {
+            match key {
+                $(
+                    Key::$key => Some($code),
+                )*
+                Key::Unknown(code) => Some(code.try_into().ok()?),
+                _ => None,
+            }
+        }
+
+        //TODO: make const when rust lang issue #49146 is fixed
+        pub fn key_from_code(code: WORD) -> Key {
+            match code {
+                $(
+                    $code => Key::$key,
+                )*
+                _ => Key::Unknown(code.into())
+            }
+        }
+    };
+}
+
+// https://docs.microsoft.com/en-us/windows/win32/inputdev/virtual-key-codes
+// We redefined here for Letter and number keys which are not in winapi crate (and don't have a name either in win32)
+decl_keycodes! {
+    Alt, 164,
+    AltGr, 165,
+    Backspace, 0x08,
+    CapsLock, 20,
+    ControlLeft, 162,
+    ControlRight, 163,
+    Delete, 46,
+    DownArrow, 40,
+    End, 35,
+    Escape, 27,
+    F1, 112,
+    F10, 121,
+    F11, 122,
+    F12, 123,
+    F2, 113,
+    F3, 114,
+    F4, 115,
+    F5, 116,
+    F6, 117,
+    F7, 118,
+    F8, 119,
+    F9, 120,
+    Home, 36,
+    LeftArrow, 37,
+    MetaLeft, 91,
+    PageDown, 34,
+    PageUp, 33,
+    Return, 0x0D,
+    RightArrow, 39,
+    ShiftLeft, 160,
+    ShiftRight, 161,
+    Space, 32,
+    Tab, 0x09,
+    UpArrow, 38,
+    PrintScreen, 44,
+    ScrollLock, 145,
+    Pause, 19,
+    NumLock, 144,
+    BackQuote, 192,
+    Num1, 49,
+    Num2, 50,
+    Num3, 51,
+    Num4, 52,
+    Num5, 53,
+    Num6, 54,
+    Num7, 55,
+    Num8, 56,
+    Num9, 57,
+    Num0, 48,
+    Minus, 189,
+    Equal, 187,
+    KeyQ, 81,
+    KeyW, 87,
+    KeyE, 69,
+    KeyR, 82,
+    KeyT, 84,
+    KeyY, 89,
+    KeyU, 85,
+    KeyI, 73,
+    KeyO, 79,
+    KeyP, 80,
+    LeftBracket, 219,
+    RightBracket, 221,
+    KeyA, 65,
+    KeyS, 83,
+    KeyD, 68,
+    KeyF, 70,
+    KeyG, 71,
+    KeyH, 72,
+    KeyJ, 74,
+    KeyK, 75,
+    KeyL, 76,
+    SemiColon, 186,
+    Quote, 222,
+    BackSlash, 220,
+    IntlBackslash, 226,
+    KeyZ, 90,
+    KeyX, 88,
+    KeyC, 67,
+    KeyV, 86,
+    KeyB, 66,
+    KeyN, 78,
+    KeyM, 77,
+    Comma, 188,
+    Dot, 190,
+    Slash, 191,
+    Insert, 45,
+    //KP_RETURN, 13,
+    KpMinus, 109,
+    KpPlus, 107,
+    KpMultiply, 106,
+    KpDivide, 111,
+    Kp0, 96,
+    Kp1, 97,
+    Kp2, 98,
+    Kp3, 99,
+    Kp4, 100,
+    Kp5, 101,
+    Kp6, 102,
+    Kp7, 103,
+    Kp8, 104,
+    Kp9, 105,
+    KpDelete, 110
+}
+
+#[cfg(test)]
+mod test {
+    use super::{code_from_key, key_from_code};
+    #[test]
+    fn test_reversible() {
+        for code in 0..65535 {
+            let key = key_from_code(code);
+            if let Some(code2) = code_from_key(key) {
+                assert_eq!(code, code2)
+            } else {
+                assert!(false, "We could not convert back code: {:?}", code);
+            }
+        }
+    }
+}
diff --git a/src/windows/listen.rs b/src/windows/listen.rs
new file mode 100644
index 0000000..bff00d2
--- /dev/null
+++ b/src/windows/listen.rs
@@ -0,0 +1,56 @@
+use crate::rdev::{Event, EventType, ListenError};
+use crate::windows::common::{convert, set_key_hook, set_mouse_hook, HookError, HOOK, KEYBOARD};
+use std::os::raw::c_int;
+use std::ptr::null_mut;
+use std::time::SystemTime;
+use winapi::shared::minwindef::{LPARAM, LRESULT, WPARAM};
+use winapi::um::winuser::{CallNextHookEx, GetMessageA, HC_ACTION};
+
+static mut GLOBAL_CALLBACK: Option<Box<dyn FnMut(Event)>> = None;
+
+impl From<HookError> for ListenError {
+    fn from(error: HookError) -> Self {
+        match error {
+            HookError::Mouse(code) => ListenError::MouseHookError(code),
+            HookError::Key(code) => ListenError::KeyHookError(code),
+        }
+    }
+}
+
+unsafe extern "system" fn raw_callback(code: c_int, param: WPARAM, lpdata: LPARAM) -> LRESULT {
+    if code == HC_ACTION {
+        let opt = convert(param, lpdata);
+        if let Some(event_type) = opt {
+            let name = match &event_type {
+                EventType::KeyPress(_key) => match (*KEYBOARD).lock() {
+                    Ok(mut keyboard) => keyboard.get_name(lpdata),
+                    Err(_) => None,
+                },
+                _ => None,
+            };
+            let event = Event {
+                event_type,
+                time: SystemTime::now(),
+                name,
+            };
+            if let Some(callback) = &mut GLOBAL_CALLBACK {
+                callback(event);
+            }
+        }
+    }
+    CallNextHookEx(HOOK, code, param, lpdata)
+}
+
+pub fn listen<T>(callback: T) -> Result<(), ListenError>
+where
+    T: FnMut(Event) + 'static,
+{
+    unsafe {
+        GLOBAL_CALLBACK = Some(Box::new(callback));
+        set_key_hook(raw_callback)?;
+        set_mouse_hook(raw_callback)?;
+
+        GetMessageA(null_mut(), null_mut(), 0, 0);
+    }
+    Ok(())
+}
diff --git a/src/windows/mod.rs b/src/windows/mod.rs
new file mode 100644
index 0000000..89e91a8
--- /dev/null
+++ b/src/windows/mod.rs
@@ -0,0 +1,18 @@
+extern crate winapi;
+
+mod common;
+mod display;
+#[cfg(feature = "unstable_grab")]
+mod grab;
+mod keyboard;
+mod keycodes;
+mod listen;
+mod simulate;
+
+pub use crate::windows::keycodes::{key_from_code, code_from_key};
+pub use crate::windows::display::display_size;
+#[cfg(feature = "unstable_grab")]
+pub use crate::windows::grab::grab;
+pub use crate::windows::keyboard::Keyboard;
+pub use crate::windows::listen::listen;
+pub use crate::windows::simulate::simulate;
diff --git a/src/windows/simulate.rs b/src/windows/simulate.rs
new file mode 100644
index 0000000..fc8f249
--- /dev/null
+++ b/src/windows/simulate.rs
@@ -0,0 +1,139 @@
+use crate::rdev::{Button, EventType, SimulateError};
+use crate::windows::keycodes::code_from_key;
+use std::convert::TryFrom;
+use std::mem::size_of;
+use winapi::ctypes::{c_int, c_short};
+use winapi::shared::minwindef::{DWORD, UINT, WORD};
+use winapi::shared::ntdef::LONG;
+use winapi::um::winuser::{
+    GetSystemMetrics, INPUT_u, SendInput, INPUT, INPUT_KEYBOARD, INPUT_MOUSE, KEYBDINPUT,
+    KEYEVENTF_KEYUP, KEYEVENTF_SCANCODE, KEYEVENTF_EXTENDEDKEY, MOUSEEVENTF_ABSOLUTE, MOUSEEVENTF_HWHEEL, MOUSEEVENTF_LEFTDOWN,
+    MOUSEEVENTF_LEFTUP, MOUSEEVENTF_MIDDLEDOWN, MOUSEEVENTF_MIDDLEUP, MOUSEEVENTF_MOVE,
+    MOUSEEVENTF_RIGHTDOWN, MOUSEEVENTF_RIGHTUP, MOUSEEVENTF_VIRTUALDESK, MOUSEEVENTF_WHEEL,
+    MOUSEEVENTF_XDOWN, MOUSEEVENTF_XUP, MOUSEINPUT, SM_CXVIRTUALSCREEN, SM_CYVIRTUALSCREEN,
+    WHEEL_DELTA, MapVirtualKeyW, MAPVK_VK_TO_VSC
+};
+/// Not defined in win32 but define here for clarity
+static KEYEVENTF_KEYDOWN: DWORD = 0;
+
+fn sim_mouse_event(flags: DWORD, data: DWORD, dx: LONG, dy: LONG) -> Result<(), SimulateError> {
+    let mut union: INPUT_u = unsafe { std::mem::zeroed() };
+    let inner_union = unsafe { union.mi_mut() };
+    *inner_union = MOUSEINPUT {
+        dx,
+        dy,
+        mouseData: data,
+        dwFlags: flags,
+        time: 0,
+        dwExtraInfo: 0,
+    };
+    let mut input = [INPUT {
+        type_: INPUT_MOUSE,
+        u: union,
+    }; 1];
+    let value = unsafe {
+        SendInput(
+            input.len() as UINT,
+            input.as_mut_ptr(),
+            size_of::<INPUT>() as c_int,
+        )
+    };
+    if value != 1 {
+        Err(SimulateError)
+    } else {
+        Ok(())
+    }
+}
+
+fn sim_keyboard_event(flags: DWORD, vk: WORD, scan: WORD) -> Result<(), SimulateError> {
+    let mut union: INPUT_u = unsafe { std::mem::zeroed() };
+    let inner_union = unsafe { union.ki_mut() };
+    *inner_union = KEYBDINPUT {
+        wVk: vk,
+        wScan: scan,
+        dwFlags: flags,
+        time: 0,
+        dwExtraInfo: 0,
+    };
+    let mut input = [INPUT {
+        type_: INPUT_KEYBOARD,
+        u: union,
+    }; 1];
+    let value = unsafe {
+        SendInput(
+            input.len() as UINT,
+            input.as_mut_ptr(),
+            size_of::<INPUT>() as c_int,
+        )
+    };
+    if value != 1 {
+        Err(SimulateError)
+    } else {
+        Ok(())
+    }
+}
+
+pub fn simulate(event_type: &EventType) -> Result<(), SimulateError> {
+    match event_type {
+        EventType::KeyPress(key) => {
+            let code = code_from_key(*key).ok_or(SimulateError)?;
+            let directinput_compatible_code = unsafe { MapVirtualKeyW(code as u32, MAPVK_VK_TO_VSC) as WORD };
+
+            sim_keyboard_event(KEYEVENTF_SCANCODE, 0, 0xE0);
+            sim_keyboard_event(KEYEVENTF_SCANCODE | KEYEVENTF_EXTENDEDKEY, 0, directinput_compatible_code)
+        }
+        EventType::KeyRelease(key) => {
+            let code = code_from_key(*key).ok_or(SimulateError)?;
+            let directinput_compatible_code = unsafe { MapVirtualKeyW(code as u32, MAPVK_VK_TO_VSC) as WORD };
+
+            sim_keyboard_event(KEYEVENTF_SCANCODE | KEYEVENTF_KEYUP | KEYEVENTF_EXTENDEDKEY, 0, directinput_compatible_code);
+            sim_keyboard_event(KEYEVENTF_SCANCODE | KEYEVENTF_KEYUP, 0, 0xE0)
+        }
+        EventType::ButtonPress(button) => match button {
+            Button::Left => sim_mouse_event(MOUSEEVENTF_LEFTDOWN, 0, 0, 0),
+            Button::Middle => sim_mouse_event(MOUSEEVENTF_MIDDLEDOWN, 0, 0, 0),
+            Button::Right => sim_mouse_event(MOUSEEVENTF_RIGHTDOWN, 0, 0, 0),
+            Button::Unknown(code) => sim_mouse_event(MOUSEEVENTF_XDOWN, (*code).into(), 0, 0),
+        },
+        EventType::ButtonRelease(button) => match button {
+            Button::Left => sim_mouse_event(MOUSEEVENTF_LEFTUP, 0, 0, 0),
+            Button::Middle => sim_mouse_event(MOUSEEVENTF_MIDDLEUP, 0, 0, 0),
+            Button::Right => sim_mouse_event(MOUSEEVENTF_RIGHTUP, 0, 0, 0),
+            Button::Unknown(code) => sim_mouse_event(MOUSEEVENTF_XUP, (*code).into(), 0, 0),
+        },
+        EventType::Wheel { delta_x, delta_y } => {
+            if *delta_x != 0 {
+                sim_mouse_event(
+                    MOUSEEVENTF_HWHEEL,
+                    (c_short::try_from(*delta_x).map_err(|_| SimulateError)? * WHEEL_DELTA) as u32,
+                    0,
+                    0,
+                )?;
+            }
+
+            if *delta_y != 0 {
+                sim_mouse_event(
+                    MOUSEEVENTF_WHEEL,
+                    (c_short::try_from(*delta_y).map_err(|_| SimulateError)? * WHEEL_DELTA) as u32,
+                    0,
+                    0,
+                )?;
+            }
+            Ok(())
+        }
+        EventType::MouseMove { x, y } => {
+            let width = unsafe { GetSystemMetrics(SM_CXVIRTUALSCREEN) };
+            let height = unsafe { GetSystemMetrics(SM_CYVIRTUALSCREEN) };
+            if width == 0 || height == 0 {
+                return Err(SimulateError);
+            }
+
+            sim_mouse_event(
+                MOUSEEVENTF_MOVE | MOUSEEVENTF_ABSOLUTE | MOUSEEVENTF_VIRTUALDESK,
+                0,
+                (*x as i32 + 1) * 65535 / width,
+                (*y as i32 + 1) * 65535 / height,
+            )
+        }
+    }
+}
diff --git a/tests/grab.rs b/tests/grab.rs
new file mode 100644
index 0000000..a3fad1e
--- /dev/null
+++ b/tests/grab.rs
@@ -0,0 +1,72 @@
+use lazy_static::lazy_static;
+use rdev::{grab, listen, simulate, Event, EventType, Key};
+use serial_test::serial;
+use std::error::Error;
+use std::sync::mpsc::{channel, Receiver, RecvTimeoutError, Sender};
+use std::sync::Mutex;
+use std::thread;
+use std::time::Duration;
+
+lazy_static! {
+    static ref EVENT_CHANNEL: (Mutex<Sender<Event>>, Mutex<Receiver<Event>>) = {
+        let (send, recv) = channel();
+        (Mutex::new(send), Mutex::new(recv))
+    };
+}
+
+fn send_event(event: Event) {
+    EVENT_CHANNEL
+        .0
+        .lock()
+        .expect("Failed to unlock Mutex")
+        .send(event)
+        .expect("Receiving end of EVENT_CHANNEL was closed");
+}
+
+fn grab_tab(event: Event) -> Option<Event> {
+    match event.event_type {
+        EventType::KeyPress(Key::Tab) => None,
+        EventType::KeyRelease(Key::Tab) => None,
+        _ => Some(event),
+    }
+}
+
+#[test]
+#[serial]
+fn test_grab() -> Result<(), Box<dyn Error>> {
+    // Wait for tester's key to go back up
+    // otherwise, test fails due to KeyRelease(Return)
+    thread::sleep(Duration::from_millis(300));
+
+    // spawn new thread because listen blocks
+    let _listener = thread::spawn(move || {
+        listen(send_event).expect("Could not listen");
+    });
+    // Make sure grab ends up on top of listen so it can properly discard.
+    thread::sleep(Duration::from_secs(1));
+    let _grab = thread::spawn(move || {
+        grab(grab_tab).expect("Could not grab");
+    });
+
+    let recv = EVENT_CHANNEL.1.lock().expect("Failed to unlock Mutex");
+
+    // Wait for listen to start
+    thread::sleep(Duration::from_secs(1));
+
+    let event_type = EventType::KeyPress(Key::KeyS);
+    let event_type2 = EventType::KeyRelease(Key::KeyS);
+    simulate(&event_type)?;
+    simulate(&event_type2)?;
+
+    let timeout = Duration::from_secs(1);
+    assert_eq!(event_type, recv.recv_timeout(timeout)?.event_type);
+    assert_eq!(event_type2, recv.recv_timeout(timeout)?.event_type);
+
+    simulate(&EventType::KeyPress(Key::Tab))?;
+    simulate(&EventType::KeyRelease(Key::Tab))?;
+    match recv.recv_timeout(timeout) {
+        Ok(event) => panic!("We should not receive event : {:?}", event),
+        Err(err) => assert_eq!(err, RecvTimeoutError::Timeout),
+    };
+    Ok(())
+}
diff --git a/tests/listen_and_simulate.rs b/tests/listen_and_simulate.rs
new file mode 100644
index 0000000..03b9809
--- /dev/null
+++ b/tests/listen_and_simulate.rs
@@ -0,0 +1,74 @@
+use lazy_static::lazy_static;
+use rdev::{listen, simulate, Button, Event, EventType, Key};
+use serial_test::serial;
+use std::error::Error;
+use std::iter::Iterator;
+use std::sync::mpsc::{channel, Receiver, Sender};
+use std::sync::Mutex;
+use std::thread;
+use std::time::Duration;
+
+lazy_static! {
+    static ref EVENT_CHANNEL: (Mutex<Sender<Event>>, Mutex<Receiver<Event>>) = {
+        let (send, recv) = channel();
+        (Mutex::new(send), Mutex::new(recv))
+    };
+}
+
+fn send_event(event: Event) {
+    EVENT_CHANNEL
+        .0
+        .lock()
+        .expect("Failed to unlock Mutex")
+        .send(event)
+        .expect("Receiving end of EVENT_CHANNEL was closed");
+}
+
+fn sim_then_listen(events: &mut dyn Iterator<Item = EventType>) -> Result<(), Box<dyn Error>> {
+    // spawn new thread because listen blocks
+    let _listener = thread::spawn(move || {
+        listen(send_event).expect("Could not listen");
+    });
+    let second = Duration::from_millis(1000);
+    thread::sleep(second);
+
+    let recv = EVENT_CHANNEL.1.lock()?;
+    for event in events {
+        simulate(&event)?;
+        let recieved_event = recv.recv_timeout(second).expect("No events to recieve");
+        assert_eq!(recieved_event.event_type, event);
+    }
+    Ok(())
+}
+
+#[test]
+#[serial]
+fn test_listen_and_simulate() -> Result<(), Box<dyn Error>> {
+    // wait for user input from keyboard to stop
+    // (i.e. the return/enter keypress to run test command)
+    thread::sleep(Duration::from_millis(50));
+
+    let events = vec![
+        //TODO: fix sending shift keypress events on linux
+        //EventType::KeyPress(Key::ShiftLeft),
+        EventType::KeyPress(Key::KeyS),
+        EventType::KeyRelease(Key::KeyS),
+        EventType::ButtonPress(Button::Right),
+        EventType::ButtonRelease(Button::Right),
+        EventType::Wheel {
+            delta_x: 0,
+            delta_y: 1,
+        },
+        EventType::Wheel {
+            delta_x: 0,
+            delta_y: -1,
+        },
+    ]
+    .into_iter();
+    let click_events = (0..480).map(|pixel| EventType::MouseMove {
+        x: pixel as f64,
+        y: pixel as f64,
+    });
+    let mut events = events.chain(click_events);
+    sim_then_listen(&mut events)
+}
